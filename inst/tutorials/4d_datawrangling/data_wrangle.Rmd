---
title: "Data Wrangling"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Mit Daten ringen. Insbesondere dplyr Funktionen werden eingef√ºhrt und ge√ºbt. 
resource_files:
- css/boxes.css
tutorial:
      id: datawrangle
      version: 1
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(learnr)
library(rtutorials)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

Im wissenschaftlichen Prozess steht die Daten-Aufbereitung
logischerweise vor der Visualisierung und Auswertung. Die Daten werden
so arrangiert, dass sie sp√§ter im richtigen Format f√ºr die Auswertung
vorliegen. Dabei werden unter anderem auch Ausrei√üer analysiert und
fehlende Werte betrachtet.

![](images/prozess.png){width="80%"}

## Lernziele

In diesem Tutorial lernst du:

-   <input type="checkbox" unchecked> Was das *tidyverse* ist</input>
-   <input type="checkbox" unchecked> Wie *saubere* Daten ausssehen
    </input>
-   <input type="checkbox" unchecked> Wie du Daten mit dem Paket `dplyr`
    arrangierst </input>
-   <input type="checkbox" unchecked> Wie du deine Daten *reinigst*
    </input>

<hr>

Einiges im folgenden orientiert sich an einem tollen, frei verf√ºgbaren R
Tutorial namens [*DoSStoolkit*](https://dosstoolkit.com/) [@rohan2023].
Wir haben die Reihenfolge ge√§ndert, Sachen √ºbersetzt und paraphrasiert
und unsere eigenen Gedanken hinzugef√ºgt.

<hr>

## Tidyverse

Wenn unsere Daten-Welt mal wieder im Chaos versinkt, gibt es einen
R√ºckzugsort, wo die Welt noch in *Ordnung* ist: das **tidyverse**.

![](images/messy_tidy.jpg){width="70%"}

*Was ist das tidyverse?* Es ist ein **Universum von Paketen**, die sich
einem bestimmten Ziel widmen, n√§mlich R f√ºr *Data Science* zu nutzen.
Dazu geh√∂rt vor allem die Arbeit mit Tabellen und Daten.

Dabei hat sich eine Art Dialekt gebildet, der das Ziel hat,
√ºbersichtlich zu sein, konsistent und nutzerfreundlich. In den meisten
F√§llen werden *tidyverse*-Funktionen diesem Anspruch gerecht und
deswegen macht es auch Sinn, sie zu nutzen.

::: gelb
Trotzdem *ein Wort der Warnung*: Alles, was mit *tidyverse*-Paketen
m√∂glich ist, l√§sst sich auch mit *Base R* erreichen. Es w√§re nicht so
schlau, die "Basis" zu vergessen, und nur noch *tidyverse* zu lernen.
*Tidyverse* schreibt selbst auf seiner
[Website](https://www.tidyverse.org/), es sei ein ‚Äûopinionated R
Package". Das hei√üt, es vertritt eine klare Meinung dar√ºber, was
eigentlich *tidy*, also aufger√§umt sein, f√ºr R bedeutet. Letztlich kann
das *tidyverse* nicht alles und nicht alle sind √ºberzeugt davon. Manche
R-Kurse entscheiden sich, um nicht zu verwirrend zu sein, nur noch
*tidyverse* zu lehren, beispielsweise @ismay2020 oder @wickham2016.
:::

</br>

Folgende Pakete geh√∂ren zum *tidyverse*:

-   `ggplot2`: konsistente *Grammar of Graphs* f√ºr Visualisierungen
    (kannst du ja sogar schon üëè)

![](images/ggplot.png){width="20%"}

-   `tidyr`: Daten in ein *tidy*-Format bringen

![](images/tidyr.png){width="20%"}

-   `dplyr`: *Data Plyers* "Datenzange"

![](images/dplyr.png){width="20%"}

-   ... und noch einige mehr, unter anderem `tibble`, `readr` and
    `purrr`.

Alle diese Pakete k√∂nnen entweder einzeln installiert werden oder alle
auf einmal, indem das Schirmpaket `tidyverse` installiert wird.

Ein Beispiel f√ºr die Design-Richtlinien, nach denen sich
*tidyverse*-Funktionen richten m√ºssen, ist keine Punkte zu verwenden in
Funktionsnamen (wie z.B. *Base R*: `as.data.frame()`), sondern
Unterstriche wie in `as_tibble()`. Das ist ein klassisches Zeichen, dass
wir uns im *tidyverse* bewegen. Au√üerdem ist dort alles *lowercase*,
also kleingeschrieben, damit es nicht zu Verwirrungen wegen Gro√ü- und
Kleinschreibung kommt.

## Von der Datenerhebung zur Analyse

Es klingt banal, aber wenn die Daten aufger√§umt sind, ist bereits die
gr√∂√üte H√ºrde geschafft. Einen Gro√üteil der Zeit von Datenanalyse
verbringen Forschende damit, Daten in die richtige Form zu bringen. Die
Auswertung selbst geht dann oft vergleichsweise schnell.

Den ganzen Aufr√§umprozess kannst du erleichtern, wenn du die Daten von
Anfang an so organisierst, dass *R* gut damit umgehen kann.

Aber was gibt es eigentlich f√ºr Formen in denen Daten vorliegen k√∂nnen?

Gleiche Daten, aber anders organisiert:

```{r}
df <- trees |> tibble::rowid_to_column(var = "id")

df |> pivot_longer(cols = !id, names_to = "variable")

df |> arrange(Height) |> pivot_wider(id_cols = "id", 
                                     names_from = "Height",
                                     names_prefix = "Height=", values_from = "Volume")
```

## Datenerhebung

Im Falle unseres Beispieldatensatzes `einkaufen` haben 8 Studierende
sich vor Biol√§den in und um Kassel gestellt und den Kund_innen Fragen
gestellt - zum Beispiel zum Lieblingsessen, wie oft sie selbst kochen
und wie weit der Weg bis zum Laden war.

Die Antworten wurden mitgeschrieben und sp√§ter in *Excel* oder *OpenOffice*
eingetippt. Damit die Analyse in R sp√§ter gut funktioniert, m√ºssen die
Daten in dieser speziellen Form eingegeben werden:

```{r}
knitr::include_graphics(path = "images/clean.png")
```

::: grau-nb
Merke: Beobachtungen sind immer die Zeilen, und Variablen immer die
Spalten.
:::

##### Variablen

Variablen sind die unterschiedlichen Fragen, die wir gestellt haben. Zum
Beispiel:

-   Wie alt sind Sie? -\> Variable: Alter

-   Wie weit war Ihr Weg in km? -\> Variable: Weg

##### Beobachtungen

Beobachtungen sind hier die einzelnen Personen, denen die Fragen
gestellt wurden. Eine Person ist dabei eine Beobachtung.

##### tidy data

Das oben vorgestellte Konzept wurde unter dem Namen "*tidy data"*
formalisiert.

Hier sind drei wichtige Grundregeln f√ºr *tidy data* nach @wickham2016:

<div>

> 1.  Jede Variable braucht ihre eigene Spalte.
>
> 2.  Jede Beobachtung braucht ihre eigene Zeile.
>
> 3.  Jeder Wert braucht seine eigene Zelle.

</div>

grafisch dargestellt: 

![](images/tidy_tableview.png){width="90%"}

Source: [R for Data Science, H. Wickham, M. Cetinkaya-Rundel, G.
Grolemund](https://r4ds.hadley.nz/data-tidy)

Mit diesen drei Grundregeln wirst du weniger Kopfschmerzen bei der
Analyse von Daten mit R bekommen.

<!-- ## tidyr -->

<!-- ![](images/tidyr.png){width="20%"} -->

<!-- Das tidyr Paket hilft uns dabei unsere Daten in ein *tidy*-Format zu bringen. Die Hauptfunktionen von *tidyr* sind: -->

<!-- - *Pivoting*: Dies erm√∂glicht die Umwandlung zwischen der langen und breiten Form eines Data Frames. In diesem Kapitel werden die Funktionen `pivot_wider()` und `pivot_longer()` vorgestellt.  -->

<!-- - Umgang mit *fehlenden Werten*: Du kannst NA-Werte mit der Funktion `drop_na()` entfernen oder du kannst `replace_na()` verwenden, um die NA-Werte durch einen bestimmten Wert zu ersetzen. -->

Stelle bei der Erhebung sicher, dass deine Daten in diesem Format
vorliegen, dann kannst du sie mithilfe des *tidyverse* nach deinen
W√ºnschen arrangieren. Im folgenden stellen wir dir daf√ºr dir das Pakete
`dplyr` und dessen Funktionen vor.

## Das Paket `dplyr`

![](images/dplyr.png){width="20%"}

`dplyr` steht f√ºr *Data Plyers*, "Datenzange". Es
enth√§lt essentielle Funktionen um deine Daten zu greifen und in Form zu bringen:

-   `rename()` l√§sst dich deine Variablen umbenennen.
-   `select()` erm√∂glicht es dir, Variablen anhand ihrer Namen
    auszuw√§hlen.
-   `arrange()`, um die Reihenfolge der Zeilen zu √§ndern.
-   `filter()`, um Zeilen basierend auf ihren Werten auszuw√§hlen.
-   `mutate()`, um neue Variablen zu erstellen
-   `group_by()`, um Funktionen gruppenweise durchzuf√ºhren
-   `summarise()`, dampt mehrere Zeilen ein zu einer einzigen zusammenfassenden Zahl

Starten wir direkt mit der ersten Funktion: `rename()`.

## rename()

Bist du mit der Wahl deiner Variablennamen unzufrieden? Die Funktion
`rename()` ist deine Rettung.

::: blau-nb
Es empfielt sich Variablen nicht mitten im Skript umzubenennen, das
sollte direkt zu Beginn, nach dem Import der Daten geschehen. So
ersparst du dir einige unn√∂tige Fehlermeldungen aufgrund nicht
auffindbarer Variablen.

M√∂chtest du dein Skript im nachhinein an die neue Schreibweise anpassen
kannst du mit dem Tastenk√ºrzel `strg + f` das entsprechende Wort im
Skript suchen und ersetzen lassen (`replace`). *Der Befehl √∂ffnet ein
kleines Extra Men√º √ºber deinem Skript.* Auch au√üerhalb von R Studio ist
es √ºbrigens ein sehr hilfreiches Tastenk√ºrzel um Texte zu durchsuchen.
:::

</br>

Was kann die Funktion `rename()`:

-   `rename()` ist hilfreich, um Spalten in etwas einfacheres und
    eindeutigeres umzubenennen.
-   Es lassen sich auch mehrere Spalten in einem Data Frame auf einmal
    umbenennen.
-   Auch nicht beschriftete Spalten (oder Spalten mit Leerzeichen)
    k√∂nnen ge√§ndert werden.

Die Syntax von `rename()` ist relativ simple und entspricht dem was wir
von R gewohnt sind:

`rename(data, new = old)`

Die Funktion nimmt als *ersten Input unseren Data Frame* (praktisch f√ºr
unsere Pipe), und m√∂chte erst den *neuen* und *dann* den *alten Namen*.
Beachte dabei die Regeln f√ºr Variablennamen (muss mit einem Buchstaben
beginnen, keine Leerzeichen, m√∂glichst aussagekr√§ftig und kurz, etc.).
Die Variablennamen m√ºssen hier jedoch nicht mit Anf√ºhrungszeichen als
String eingegeben werden, da sie eben Variablen sind, denen wir etwas
zuweisen.

::: blau-nb
Jetzt ist auch die Zeit gekommen, in der dein Wissen und K√∂nnen zum
Thema Pipe-Operator `|>` n√ºtzlich wird. Diesen werden wir heute
umfassend nutzen.

Falls du im Internet Code findest der diese Pipe `%>%` verwendet, die
stammt ebenfalls aus dem *tidyverse*. Beide funktionieren in diesem
Tutorial.

Die Pipe kannst du wie gewohnt mit der Tastenkombination
`strg bzw. Cmd + shift + M` hinzuf√ºgen.
:::

</br>

Hier ein erstes Beispiel, wie du die Funktion nutzen kannst, um
`frequenz` zu `freq` und `bioladen` zu `bio` umzubenennen: (hier nur zur
Veranschaulichung, die Namen waren vorher schon gut gew√§hlt).

```{r rename1, exercise = TRUE}
# abspeichern als einkaufen_rn (renamed)
einkaufen_rn <- einkaufen |>
  rename(freq = frequenz,
         km = weg)

head(einkaufen_rn)
```

Wir speichern das Ergebnis auch direkt als Datensatz ab, damit die
√Ñnderungen einen Effekt haben. Nat√ºrlich k√∂nntest du es auch in dem
originalen Datensatz abspeichern und damit weiterarbeiten.

### rename() mit Index

Falls die Variablen aus einem anderen Programm stammen und evtl.
aufgrund von Leerzeichen nicht richtig von R interpretiert werden
k√∂nnen, l√§sst sich die Spalte auch durch den Index bearbeiten:

Daf√ºr solltest du dir zun√§chst die Variablennamen ausgeben lassen
(`names(data)`), oder in deinem Datensatz anschauen an welcher Stelle
die Variablen stehen, die du √§ndern m√∂chtest.

```{r rename2, echo = TRUE}
names(einkaufen)
```

Um den Namen zu √§ndern, gib anstelle des alten Namens die Position der
Spalte ein:

```{r rename3, exercise = TRUE}
# √§ndert Spalte 2 von `verkehrsmittel` zu `mode`
einkaufen_neu <-  einkaufen |>
  rename(mode = 2)

head(einkaufen_neu)
```

Wenn du es selbst ausprobieren m√∂chtest, nutze gerne den Codechunk zum
experimentieren.

Damit hast du die erste Funktion bereits erfolgreich erkundet.üëè

::: blau-nb
Richtig lernen, wie es funktioniert wirst du am besten, wenn du den Code
auf deine eigenen Daten au√üerhalb dieses Tutorials anwendest. Denn wir Menschen lernen durch die Handlung, nicht durch das Lesen. 
:::

## select()

In diesem Kaptiel wirst du lernen, wie du die Funktion `select()`
verwendest.

Wenn du mit gro√üen Datens√§tzen arbeitest, stellst du m√∂glicherweise
fest, dass es schwierig ist, einen √úberblick √ºber deinen Datensatzen zu behalten.
Vielleicht fragst du dich, wie du nur die Variablen ausw√§hlen kannst,
die du f√ºr die Analyse oder Ausgabe verwenden m√∂chtest. Nun, es gibt
eine super M√∂glichkeit, die von dir ausgew√§hlten Variablen zu fassen:
`select()`.

So sieht die Funktion aus:

`select(data, variables)`

Die Ausgabe der Funktion ist eine Teilmenge der Eingabedaten (Spalten),
m√∂glicherweise in einer anderen Reihenfolge. Die Funktion `select()`
ver√§ndert jedoch nicht den Originaldatensatz/die Originalspalten. Wenn
du also die neuen ausgew√§hlten Spalten verwenden m√∂chtest, musst du
diese einer neuen Variable zuweisen. (Dieser Prozess wird auch
*subsetting* genannt, weil du ein Sub-Set aus deinen Daten erstellst.)

Hier ist ein einfacher Datensatz mit durchschnittlichen Temperaturen f√ºr
jede Jahreszeit. Wie du in der Ausgabe sehen kannst, gibt es 3
Beobachtungen (Zeilen) und 4 Variablen (Spalten) im Datensatz.

```{r temperature, exercise = TRUE, exercise.cap = "select()"}
temperature_data <- tibble(spring = c(3, 5, 10), 
                  summer = c(23, 27, 25), 
                  fall = c(19, 17, 14), 
                  winter = c(2, -1, -8)) 
temperature_data
```

Nehmen wir an, wir m√∂chten nur die Temperaturen im Fr√ºhling (*spring*)
sehen. Um dies zu tun, w√§hle die Variable aus, die du behalten m√∂chtest,
indem du den Variablennamen in die Funktion `select()` einf√ºgst.

### Beispiele

M√∂chten wir nur die Spalte `spring` sehen, sieht der Code daf√ºr so aus:

```{r select1, exercise = TRUE, exercise.setup = "temperature", exercise.cap = "select()"}
select(temperature_data, spring)
```

Es ist jedoch wichtig zu wissen, dass sich die Daten in
`temperature_data` nicht ge√§ndert haben, wie du sehen kannst. Die
Funktion ver√§ndert den Originaldatensatz nicht.

```{r select2, exercise = TRUE, exercise.setup = "temperature", exercise.cap = "select()"}
temperature_data
```

Wenn du den neuen Datensatz mit der Variable `spring` verwenden
m√∂chtest, musst du die ausgew√§hlte Spalte einer neuen Variable zuweisen:

```{r select3, exercise = TRUE, exercise.setup = "temperature", exercise.cap = "select()"}
new_data <- select(temperature_data, spring)
new_data
```

Du kannst auch **mehrere Variablen durch Kommas getrennt ausw√§hlen**,
solange der Datensatz der erste Input der Funktion ist. Geanu hier ist
dann auch die Pipe n√ºtzlich, da wir das damit sicherstellen.

```{r select4, exercise = TRUE, exercise.setup = "temperature", exercise.cap = "select()"}
temperature_data |>
  select(summer, winter)
```

### Operatoren:

Jetzt wissen wir, wie die Funktion `select()` funktioniert. Es gibt
dar√ºber hinaus noch verschiedene M√∂glichkeiten, die Funktion mit diesen
hilfreichen Operatoren zu erweitern:

-   `!` eine Aussage oder eine Spalte **negieren**
-   `|` **ODER**-Operator
-   `&` **UND**-Operator
-   `-` eine Spalte **ausschlie√üen**
-   `:` eine Reihe **aufeinanderfolgender Variablen ausw√§hlen**

</br>

**Der Operator `!`** verneint eine Auswahl:

```{r select5, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
select(!winter)
```

</br>

**Die Operatoren `|` und `&`** w√§hlen die Vereinigung (`|`) oder eine
Schnittmenge (`&`) der Auswahlen aus.

```{r select6, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |>
select(winter | summer)
```

</br>

::: gelb
Beachte: `select(temperature_data, winter & summer)` w√ºrde hingegen
einen Fehler verursachen, da es keine Werte geben kann, die eine
Schnittmenge aus Winter und Sommer sind. `&` ist besser daf√ºr geeignet
nach Bedingungen zu filtern, wie du es vielleicht noch vom Indizieren
her kennst.
:::

</br>

**Der Operator `:`** w√§hlt einen Bereich aufeinanderfolgender Variablen
aus, beginnend mit der Variable links des Doppelpunkts bis zur Variable
rechts des Doppelpunkts.

```{r select7, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(summer:winter)
```

</br>

**Der Operator `-`** schlie√üt eine Spalte aus.

Wenn du die meisten Spalten im Datensatz ausw√§hlen m√∂chtest und nur
einige Spalten ausschlie√üen m√∂chtest, gibt es eine einfachere
M√∂glichkeit. Du kannst einfach - vor den Namen der Spalte setzen, die du
ausschlie√üen m√∂chtest. Zum Beispiel m√∂chte ich die Spalten "summer" und
"winter" ausschlie√üen, dann setze ich einfach ein - vor die Spalten:

```{r select8, exercise = TRUE, exercise.setup = "temperature"}
temperature_data |> 
  select(-summer, -winter)
```

**Jetzt bist du dran!**

::: aufgabe
Lasse dir vom Datensatz `einkaufen` nur die Variablen `verkehrsmittel`
und `alter` ausgeben.
:::

```{r q1_select, exercise = TRUE, exercise.cap = "2 Variablen ausw√§hlen"}

```

```{r q1_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q1_select-solution}
einkaufen |>
   select(verkehrsmittel, alter) 
```

::: aufgabe
Lasse dir vom Datensatz `einkaufen` alle Variablen bis auf `id` und
`datum` ausgeben.
:::

```{r q2_select, exercise = TRUE, exercise.cap = "2 Variablen ausschlie√üen"}

```

```{r q2_select-hint}
# f√ºge der Funktion select die entsprechenden Variablen hinzu
einkaufen |>
   select() 
```

```{r q2_select-solution}
einkaufen |>
   select(-id, -datum) 
```

```{r q3_select}
question_checkbox("Es gibt Variablen `id`, `gpa`, `age`, `height`, `weight` in einem Datensatz `data`. 
                  Du m√∂chtest *nur* die Variablen `id`, `height` und `weight` ausw√§hlen. Was solltest du schreiben?",
  answer("data |> select (id, height, weight)", 
         correct = TRUE),
  answer("data |> select (id & height & weight)", 
         message = "Bei dem & Operator ist es etwas tricky. Erinnere dich, dass alle Bedingungen TRUE sein m√ºssen, damit die Bedingung erf√ºllt ist. Es gibt logischerweise keine Variable, die sowohl id, height und weight  beinhaltet."),
  answer("data |> select (id | height | weight)", 
         correct = TRUE),
  answer("data |> select (id | height:weight)", 
         correct = TRUE),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = "Versuche es erneut. Du schaffst das!"
)
```

Super, das sitzt! üëå Dann kann es jetzt zur n√§chsten `dplyr` Funktion
weitergehen.

## arrange()

Manchmal m√∂chtest du einen Datensatz in einer bestimmten Reihenfolge
anzeigen lassen. Datens√§tze werden oft in der Reihenfolge angezeigt, in
der die Daten eingegeben wurden, aber du m√∂chtest ihn m√∂glicherweise
nach einer anderen Variable sortiert sehen. Du kannst die *tidyverse*
`arrange()`-Funktion verwenden, um einen Datensatz nach einer bestimmten
Spalte zu sortieren.

Die `arrange()`-Funktion nimmt einen Dataframe und die zu sortierenden
Spalten als Eingabe entgegen und gibt den neu geordneten Dataframe aus.
`arrange()` √§ndert dabei keine Werte in deinen Daten, sondern √§ndert nur
die Darstellung.

```{r arrange1, exercise = TRUE}
einkaufen |>
  arrange(weg) |> 
  select(weg, alter, frequenz)
```

Du siehst, die Wegl√§nge ist nun aufsteigend arrangiert worden. Auch hier
kannst du die Funktion f√ºr mehrere Variablen gleichzeitig nutzen:

```{r arrange2, exercise = TRUE}
einkaufen |>
  arrange(weg, alter) |> 
  select(weg, alter, essen)
```

::: gelb
Aber Vorsicht: Dir wird aufgefallen sein, dass Alter zwar etwas sortiert wurde, aber nur in den F√§llen, in denen die Menschen die gleiche Wegl√§nge angegeben haben. Es wird also prim√§r nach `weg` sortiert und dann erst nach `alter`.
:::

</br>

::: blau-nb
Auch hier gilt: Es gibt viele Wege das Ziel zu erreichen. Die *Base R*
Variante `sort()` kennst du ja auch bereits, die einen gegebenen
**Vektor** sortieren kann:
:::

```{r sort, exercise = TRUE}
einkaufen$weg |>
  sort(decreasing  = T) 
```

In einem Data Frame bietet sich `arrange()` jedoch besser an, da
`sort()` nur einen einzelnen Vektor sortiert.

## filter()

Die `filter()`-Funktion wird verwendet, um *Zeilen* aus einem gegebenen
Data Frame *basierend auf bestimmten Kriterien zu extrahieren*. Alle
Zeilen, die diese Kriterien nicht erf√ºllen, werden verworfen.

Diese Kriterien werden in Form von **logischen Bedingungen**
geschrieben. Zum Beispiel k√∂nnen wir,
wenn ein DataFrame `ToothGrowth` eine Variable namens `len` f√ºr *length*
hat, alle Zeilen extrahieren, bei denen `len` gleich 22 ist, mit dem
Ausdruck `len == 22.0`. Es kann eine *einzelne* Bedingung oder *mehrere*
Bedingungen vorhanden sein.

Einige n√ºtzliche Funktionen und Operatoren sind:

-   `==`, `>`, `<`, `>=`, `<=`
-   `&`, `|`, `!`, `xor()`
-   `is.na()`

`filter()` funktioniert dabei √§hnlich wie das Indizieren anhand von
eckigen Klammern `[]` in *Base R*. Allerdings, falls beim Auswerten
unserer Bedingungen auf einer Zeile NAs auftreten, verwirft `filter()`
diese Zeilen, w√§hrend `[]` diese weiterhin extrahiert. Das solltest du
also unbedingt im Kopf behalten.

### Welche Argumente nimmt `filter()`?

`filter(data, Bedingungen)`

-   `.data`: den Data Frame, mit dem wir arbeiten
-   `...`: die Bedingungen f√ºr die zu extrahierenden Zeilen


### Welchen Wert gibt `filter()` zur√ºck?

`filter()` gibt einen Data Frame zur√ºck, der eine *Teilmenge der Zeilen*
des Data Frames basierend auf den definierten Bedingungen oder Kriterien
enh√§lt. Dabei bleiben die Spalten unver√§ndert und die Reihenfolge der
Zeilen bleibt ebenfalls gleich. Aber schauen wir es uns doch einfach mal
an.

Angenommen, wir interessieren uns nur f√ºr die Antworten von Menschen,
deren Lieblingsessen "Pasta" ist. So k√∂nnten wir mit dem folgenden Code
entsprechend nur jene Zeilen ausgeben lassen, bei denen die Befragten
"Pasta" als Lieblingsessen angaben.

```{r filter1, exercise = TRUE}
einkaufen |> 
filter(essen == "Pasta")
```

::: aufgabe
√Ñndere den Code so um, dass stattdessen nach dem Verkehrsmittel
"Fahrrad" gefiltert wird.
:::

```{r filter2, exercise = TRUE, exercise.cap = "Filtern mit 1 Variable"}
einkaufen |> 
filter(essen == "Pasta")
```

```{r filter2-solution}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

Das hat doch schon mal super geklappt! Gehen wir also einen Schritt
weiter.

::: aufgabe
√Ñndere den Code so um, dass sowohl nach dem Verkehrsmittel "Fahrrad" als
auch einer Wegl√§nge (`weg`) von √ºber `5`km gefiltert wird.
:::

```{r filter3, exercise = TRUE, exercise.cap = "Filtern mit 2 Variablen"}
einkaufen |> 
filter()
```

```{r filter3-hint}
# f√ºge der ersten Filterbedingung mit dem &-Operator eine weitere Bedingung f√ºr `weg ist gr√∂√üer 5` hinzu.
einkaufen |> 
filter(verkehrsmittel == "Fahrrad")
```

```{r filter3-solution}
einkaufen |> 
filter(verkehrsmittel == "Fahrrad" & weg > 5)
```

Noch eine kurze √úbung zu den NAs. Wie du oben bereits gelesen hast,
werden als default NAs in deiner zu filternden Variable herausgefiltert.
M√∂chtest du dir hingegen nur die NAs einer Variable anzeigen lassen, so
ist auch das mit der `filter()` Funktion m√∂glich. Daf√ºr nutzen wir die
Funktion `is.na(*variable*)` innerhalb der `filter()` Funktion. Das
sieht dann so aus:

```{r filter4, exercise = TRUE}
einkaufen |> 
filter(is.na(ort))
```

```{r q1_filter}
question_radio("Welche der folgenden Codes ist korrekt?",
  answer("data |> filter(id & weight)", 
         message = "`filter()` braucht spezifische Bedingungen, die mittels Operatoren bewerkstelligt werden. M√∂chtest du nur die Variablen ausw√§hlen, kannst du daf√ºr `select()` nutzen.") ,
  answer("data |> filter(weight = 60)", 
         message = "`=` ist kein g√ºltiger Operator. Nutze daf√ºr `==`"),
  answer("data |> filter(height <= 1,80)", 
         correct = TRUE),
  answer("data |> filter(farbe == gr√ºn)", 
         message = "String-Variablen m√ºssen in Anf√ºhrungszeichen geschrieben werden, damit R sie nicht als eine Variable interpretiert."),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")
)
```

Super, auch das hast du gemeistert! Weiter geht¬¥s!

## mutate()

Die `mutate()`-Funktion in R, die durch das Paket `dplyr` bereitgestellt
wird, erm√∂glicht es, neue Spalten zu deinem Data Frame hinzuzuf√ºgen oder
vorhandene Spalten zu ver√§ndern, basierend auf bestimmten Berechnungen
oder Transformationen. Dies ist besonders n√ºtzlich, um neue
Informationen aus vorhandenen Daten zu generieren oder um bestehende
Daten zu modifizieren.

Um `mutate()` zu nutzen, m√ºssen wir angeben, welcher Data Frame
bearbeitet werden soll, gefolgt von der Definition der neuen oder zu
ver√§ndernden Spalte(n). Die Syntax lautet:

`mutate(data, new_column = expression)`

- `data`: Der Data Frame, der bearbeitet werden soll. 
- `new_column`: Der Name der neuen Spalte oder einer vorhandenen Spalte, die modifiziert werden soll. 
- `expression`: Die Berechnung oder Transformation, die auf
die Daten angewendet werden soll.

Mutate ist somit eine *window function*, das bedeutet, die Funktion
**nimmt** als Input **einen Vektor und gibt auch wieder einen gleichlangen Vektor aus**.

![](images/windowfunc.png){width="70%"}

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Beispiel

Angenommen, wir wollen f√ºr unseren Data Frame `einkaufen` den Weg nicht nur in km sondern auch in Meter verf√ºgbar haben. Um eine neue Spalte `weg_m` zu berechnen, k√∂nnten wir folgenden Code verwenden:

```{r mutate1, exercise = TRUE}
# nur weg ausw√§hlen, um den data frame zur Veranschaulichung klein zu halten
einkaufen |> 
  select(weg) |> 
  mutate(weg_m = weg*1000)
```

Willst du die neue Variable jedoch deinem Data Frame hinzuf√ºgen, so
musst du diese mit dem Assignment auch noch zuweisen:

```
einkaufen <-  einkaufen |> 
  mutate(weg_m = weg*1000)
```

::: gelb
Vorsicht, benutzt du bei dem Assignment in der Pipe auch die
`select()`-Funktion, so verlierst du dabei die anderen Variablen deines
Datensatzes. F√ºr solche F√§lle kannst du besser einen neuen Data Frame
erstellen.
:::

</br>

Das Ergebnis des obrigen Codebeispiels, kannst du dir grafisch so vorstellen:

![](images/dfmutate.png){width="80%"} 

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Aber `mutate()` kann noch vieles mehr als eine neue Variable berechnen.
Schau dir daf√ºr gerne auch das [Cheat Sheet vom Paket
dyplr](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)
an.

### Expertenlevel

Eine sehr interessante M√∂glichkeiten von `mutate()` ist die bedingte
Mutation. Hier k√∂nnen Spalten basierend auf bestimmten Bedingungen
erstellt werden.

Nehmen wir an, wir wollen eine unserer metrischen Variablen in selbst
gew√§hlte Kategorien aufteilen. Daf√ºr nutzen wir die Funktion
`ifelse(B, y, z)` in `mutate()`. 

Damit sagen wir R, wenn Bedingung `B`,dann `x` ansonsten `y`.

In einem Beispiel ist dies bestimmt leichter zu verstehen:

```{r ifelse, exercise = TRUE}
einkaufen <- einkaufen |> 
  mutate(weglaenge = ifelse(weg > 5, "fern", "nah"))

einkaufen |>  
  select(weg, weglaenge)
```

Hier haben wir eine neue Spalte `weglaenge` erstellt, die basierend auf
der Bedingung, ob (*if*) der Weg "gr√∂√üer" als 5km ist, den Wert "fern"
oder ansonsten (*else*) "nah" enth√§lt. Ziemlich cool, wenn man
verstanden hat wie es funktionert.

Wenn du magst, probiere es doch gleich mal selbst aus:

::: aufgabe
Erstelle eine neue kategoriale Variable `alterskategorien` aus `alter`.
W√§hle dabei nach deinem Ermessen was du f√ºr "jung" und "alt" h√§lst, denn
das ist nicht objektiv, wie es bei einer metrischen Variable w√§re.

Zur Hilfe: `ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")`
:::

```{r jungundalt, exercise = TRUE, exercise.cap = "Kategorien erstellen"}

```

```{r jungundalt-hint}
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(Bedingung, "erf√ºllt", "nicht_erf√ºllt")
         )
```

```{r jungundalt-solution}
# f√ºr mich sind Menschen unter 18 jung und dar√ºber alt
einkaufen_alter <-  einkaufen |> 
  select(alter) |> 
  mutate(alterskategorien = 
           ifelse(alter > 18, "alt", "jung")) 

# wir k√∂nnen uns dar√ºber hinaus auch die Kategorien z√§hlen lassen:
einkaufen_alter |>  
  count(alterskategorien)
```

Wow, das war wirklich nicht leicht! Dann sind die folgenden Fragen f√ºr
dich auch kein Problem:

```{r q1_mutate}
quiz(caption = "Teste dein Wissen zu `mutate()`!",
     
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Die durch `mutate()` neu berechnete Variable hat *gleich viele* Zeilen wie die Variable aus der sie berechnet wurde",
         correct = TRUE),
    answer("Die durch `mutate()` neu berechnete Variable kann auch *mehr Zeilen* als die Variable aus der sie berechnet wurde enthalten", 
         message = "Dass die neu berechnete Variable mehr Zeilen hat, ist rechnerisch nicht m√∂glich, da sie sich ja aus den bestehenden Werten berechnet"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de")),
  
  question_radio("Welche Aussage √ºber `mutate()` ist korrekt?",
    answer("Um die neu berechnete Variable zu speichern, muss der Assignment Operator genutzt werden",
         correct = TRUE),
    answer("Die neu berechnete Variable wird in dem Data Frame gespeichert", 
         message = "Du siehst beim Ausf√ºhren von `mutate()` zwar das Ergebnis, aber zum tats√§chlichen Speichern wird wie immer der `<-` Assignment Pfeil ben√∂tigt"),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de"))
  
)
```

## group_by()

Ein wichtiger Teil der Datenanalyse besteht darin, zu sehen, wie **deine
Daten in bestimmten Gruppen** aussehen, und die `group_by()` Funktion
ist dabei sehr hilfreich. Die `group_by()` Funktion nimmt einen
Datensatz und erm√∂glicht es dir, andere Funktionen zu verwenden, um eine
Vorstellung davon zu bekommen, wie diese Gruppen aussehen.

Wenn du beispielsweise einen Datensatz mit den H√∂hen und Gewichten
verschiedener Tiere hast, ist die `group_by()` Funktion n√ºtzlich, um
Dinge wie das durchschnittliche Gewicht jedes Tiertyps im Datensatz zu
finden. Die Funktion `ungroup()` wird verwendet, um die Gruppierung
durch die `group_by()` Funktion aufzuheben.

Normalerweise wird die `group_by()` Funktion mit anderen
`dplyr`-Funktionen kombiniert, um deine Analyse durchzuf√ºhren.

Zusammengefasst:

-   Die `group_by` Funktion erm√∂glicht es dir, Datens√§tze nach von dir
    ausgew√§hlten Variablen zu gruppieren.
-   `group_by` funktioniert am besten, wenn es mit anderen
    `dplyr`-Funktionen kombiniert wird, um entweder die Anzahl der
    Elemente in einer Gruppe zu z√§hlen oder neue Variablen aus den
    Gruppen zu erstellen.
-   m√∂chtest du die Gruppierung wieder aufheben, nutzt du die Funktion
    `ungroup()`.

Grafisch kannst du dir das Gruppieren so vorstellen:

![](images/groupby1.png){width="80%"} 

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Argumente

-   **`group_by(data, variables)`**: Die beiden Hauptargumente f√ºr `group_by` sind die
    **Daten**, die du analysieren m√∂chtest, und die **Variablen, nach denen du gruppieren m√∂chtest**.

-   **`ungroup(data)`**: Die Funktion `ungroup()` nimmt **ein Argument**
    entgegen, den gruppierten **Datensatz**, f√ºr den du die Gruppierung aufheben m√∂chtest.

### Beispiel

Lass uns direkt einsteigen und den `einkaufen` Datensatz nach
Verkehrsmittel aufteilen und als neuen Datensatz `einkaufen_grouped`
speichern.

```{r example_1groupby, exercise = TRUE, echo = T}
einkaufen_grouped <- einkaufen |>  
  group_by(verkehrsmittel)

head(einkaufen_grouped)
```

Huch da scheint erstmal nichts passiert zu sein, die Reihenfolge ist
weiterhin zuf√§llig. Das liegt daran, dass die Funktion normalerweise in Kombination mit anderen Funktionen erst zur Geltung kommt.

Z√§hlen wir mit der Funktion `count()` z.B. noch die Verkehrsmittel, wird
es ersichtlich:

```{r example_2groupby, exercise = TRUE}
einkaufen |>  
  select(verkehrsmittel) |> 
  count()

einkaufen |>  
  group_by(verkehrsmittel) |> 
  count()
```

Anstelle der Anzahl an Eintr√§gen (166) f√ºr `verkehrsmittel` z√§hlt
`count()` mithilfe der `group_by()` Funktion die Anzahl f√ºr jede
Kategorie.

Das kannst du dir grafisch so vorstellen:

![](images/groupby2.png){width="80%"}

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

### Probiere es doch selbst mal aus.

::: aufgabe
Gruppiere (`group_by()`) den Datensatz `einkaufen` nach `ort` und lass
dir mit `count()` anzeigen wie viele Eintr√§ge es f√ºr jeden Ort gibt.
:::

```{r groupby1, exercise = TRUE, excercise.cap = "Gruppieren √ºben"}

```

```{r groupby1-hint}
# f√ºge der Funktion group_by() das entsprechende Argument hinzu
einkaufen |> 
  group_by() |> 
  count()
```

```{r groupby1-solution}
einkaufen |> 
  group_by(ort) |> 
  count()
```

Nice! Die Grundlage hast du nun verstanden. Gehen wir also einen kleinen
Schritt weiter und Gruppieren den Datensatz nach 2 Variabeln. Daf√ºr
kannst du wie gewohnt einfach durch ein Komma getrennt eine weitere
Variable in die Funktion `group_by()` einf√ºgen.

::: aufgabe
Gruppiere den Datensatz `einkaufen` nach `bioladen` UND
`verkehrsmittel`, lass dir mit `count()` anzeigen wie viele Eintr√§ge es
f√ºr die entehenden Gruppen gibt.
:::

```{r groupby2, exercise = TRUE, excercise.cap = "Gruppieren mit 2 Variablen"}
einkaufen |> 
  group_by() |> 
  count()
```

```{r groupby2-solution}
einkaufen |> 
  group_by(ort, verkehrsmittel) |> 
  count()
```

Es lassen sich zwar beliebig viele Variablen zur Gruppierung hinzuf√ºgen,
aber sinnvoll ist das nicht unbedingt, da die Kategorien schnell so
viele neue Gruppen erstellen, dass jede Gruppe am Ende aus 1-2 Eintr√§gen besteht. Einen Mittelwert oder √§hnliches hieraus zu berechnen w√§re nicht sinnvoll.

```{r groupby3, exercise = TRUE, excercise.cap = "Gruppieren mit vielen Variablen"}
einkaufen |> 
  group_by(verkehrsmittel, weg, alter) |> 
  count()
```

Du siehst, wir haben so wieder 165 Kategorien, also nur 1 Kategorie weniger als Eintr√§ge insgesamt.

### group_by() und mutate()

Kommen wir zu unserem "Expertenlevel" der Funktion `group_by()`. Die
Verkn√ºpfung mit der zuvor gelernten Funktion `mutate()`.

```         
einkaufen |>
  group_by(ort) |>
  mutate(neue_variable = mean(weg))
```

```{r q1_groupmutate}

question_radio("Was denkst du passiert wenn wir group_by() und mutate() wie im oben stehenden Beispiel verkn√ºpfen?)",
  answer("Zeilenanzahl von `neue_variable` entspricht der Anzahl der Zeilen von `weg`",
         correct = TRUE),
  answer("Zeilenanzahl von `neue_variable` entspricht der Anzahl der Kategorien von `bioladen`",
         message = "Das war ein guter Gedanke, tats√§chlich enth√§lt die Variable jedoch genau so viele Zeilen wie `weg`. Lies weiter im Tutorial, um zu verstehen warum das so ist."),
  allow_retry = TRUE,
  random_answer_order = TRUE,
  incorrect = random_encouragement("de"),
  correct = random_praise("de"))

```

#### neue Variablen mit group_by()

Was dir vielleicht zun√§chst komisch erscheint, hat dennoch ein
hinterliegendes System und Verwendung.

Um zu verstehen was durch die Verkn√ºpfung mit `mutate()` entstanden ist
auch hier f√ºr dich die grafische Darstellung:

![](images/groupby3.png){width="70%"}

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Willst du wie im angegebenen Beispiel f√ºr jede Gruppe den Mittelwert
berechnen und als neue Variable abspeichern, erh√§ltst du logischerweise
einen Vektor mit Dopplungen f√ºr jeden Eintrag einer Kategorie. Sehen wir
uns die Ausgabe gemeinsam an:

```{r groupmutate, exercise = TRUE, excercise.cap = "group & mutate"}
einkaufen <- einkaufen |>
  group_by(frequenz) |>
  mutate(weg_mean = mean(weg, na.rm = T)) 

einkaufen|>
  select(frequenz, weg_mean, verkehrsmittel)

```

Auf diesem Wege k√∂nntest du z.B. h√§ndisch die Abweichung vom Mittelwert
der Gruppe errechnen, in dem du die Spalte `weg - weg_mean` rechnest. 

```{r groupmutate1, exercise = TRUE, exercise.setup = "groupmutate", excercise.cap = "group & mutate"}
 einkaufen |>
  mutate(weg_abw = weg - weg_mean) |>
  select(weg, weg_mean, weg_abw)
```

Aber keine Angst, auch daf√ºr gibt es in *R* bereits geeignete Funktionen, das soll hier nur als Beispiel dienen.

### ungroup()

Zu guter letzt noch die versprochene `ungroup()` Funktion, die du nutzen
kannst, wenn du keinen neuen Data Frame erstellt hast und stattdessen
deinen urspr√ºnglichen Data Frame wieder *un-gruppieren* m√∂chtest:

```{r ungroupby1, exercise = TRUE, exercise.cap = "Gruppieren mit vielen Variablen"}
einkaufen |> 
  group_by( bioladen) |> 
  count()

einkaufen |> 
  group_by( bioladen) |> 
  ungroup() |> 
  count()
```

Du siehst, die Funktion `ungroup()` revidiert die Aufhebung. In der Console w√ºrdest du auch vor jedem Output sehen, dass die Daten Gruppiert wurden. Hier mit `bioladen` und [2] Kategorien.

Anfang der Consolen-Ausgabe von `count()` mit Guppierung:

```         
# A tibble: 2 √ó 2
# Groups:   bioladen [2]
```

und Ausgabe von `count()` nach `ungroup()`:

```         
# A tibble: 1 √ó 1
```

Nat√ºrlich w√ºrdest du es in deinem Code nicht so schreiben wie oben
dargestellt, sondern als alleinstehende Zeile nach deinen Analysen der Gruppen den Code so anf√ºgen:

```         
einkaufen <- einkaufen |> 
  ungroup() 
```

## summarise()

`summarise()` verwendet Zusammenfassungs-Funktionen, d.h. die Funktionen
*nehmen einen Vektor von Werten* und geben einen **einzelnen Wert** *zur√ºck*:

![](images/summarize.png){width="80%"}

[Source:CheatSheet](https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf)

Es gibt viele Zusammenfassungs-Funktionen, die du innerhalb von
`summarise()` verwenden kannst, unter anderem:

-   `min()` (Minimum)

-   `max()` (Maximum)

-   `sum()` (Summe)

-   `var()` (Varianz)

-   `sd()` (Standardabweichung)

-   `mean()` (Mittelwert)

Dabei wird `summarise()` wird oft mit `group_by()` verwendet.

Schauen wir uns die Verwendung der Funktion in Aktion an:

```{r summarise1, exercise = TRUE}
einkaufen |> 
  summarise(weg_m = sum(weg))
```

Wir bekommen ein `NA`?! Komisch? Nein, erinnere dich daran, dass R sobald ein `NA` in der Rechnung beteiligt ist, dir stehts `NA` als Antwort ausgibt.

F√ºr uns kein Problem, wir sagen der Funktion `sum()` mit dem
Zusatzargument `(na.rm = T)`, dass sie die `NA`s nicht mit in die Rechnung einbeziehen soll:

```{r summarise2, exercise = TRUE}
einkaufen |> 
  summarise(weg_m = sum(weg, na.rm = T))
```

Jetzt bist du dran!

::: aufgabe
Finde den Maximalwert f√ºr die Variable `weg` f√ºr jeden `ort`. Verwende
wieder `na.rm = T` in der Zusammenfassungs-Funktion
:::

```{r summarise3, exercise = TRUE, exercise.cap = "Zusammenfassen"}

```

```{r summarise3-hint}
einkaufen |>
  group_by() |> 
  summarise()
```

```{r summarise3-solution}
einkaufen |>
  group_by(ort) |> 
  summarise(weg_max = max(weg, na.rm = T))
```

Ich m√∂chte dir noch eine Zusammenfassungs-Funktion zeigen, die f√ºr den
Beispieldatensatz hilfreich ist: `n_distinct()`. Die Funktion z√§hlt alle
unterschiedlichen (distinkten) Werte in einer Variable. Das k√∂nnen wir
gut f√ºr die Variable `essen` nutzen.

Probiere es doch mal aus.

::: aufgabe
Nutze die Funktion `n_distinct()`, um f√ºr die variable `essen`, alle unterschiedlichen Eintr√§ge zu z√§hlen.
:::

```{r summarise4, exercise = TRUE, exercise.cap = "n_distinct"}
einkaufen |>
  summarise(anzahl_lieblingsgerichte = n_distinct())
```

```{r summarise4-solution}
einkaufen |>
  summarise(anzahl_lieblingsgerichte = n_distinct(essen))
```

Super auch das hast du jetzt verstanden! Vielleicht geht dir auch
langsam die Logik von R ins Blut und die Finger √ºber und du beherrscht so langsam die Daten-Magie. üßô

## Exkurs: Check your data

Jetzt wo du wei√üt, wie du deine Daten arrangieren kannst, wird es auch
Zeit das Thema Ausrei√üer und Datenreinigung anzusprechen.

Dazu wollen wir zuerst kurz definieren, was Ausrei√üer sind und ergr√ºnden
weshalb sie entstehen, um dann kurz aufzuzeigen, wie du damit umgehen
kannst.

### Definition

**Ausrei√üer**, sind Werte, die **nicht aus unserer Population** stammen.
*Extreme Werte* hingegen, sind ungew√∂hnlich, aber geh√∂ren zu der selben
Population.

Das klingt dann doch sehr technisch, hier ein weltliches Beispiel zum
Verst√§ndnis:

Nehmen wir an, wir wollen das Durchschnittsgewicht von Kamelen messen.

![](images/kamelvsdromedar.png){width="60%"} 

Tierliebhabende sehen sofort, hier haben sich doch einige Dromedare in unsere Herde
geschlichen! Das sind in dem Fall *Ausrei√üer*, die wir f√ºr unsere
Analysen ausschlie√üen sollten, da wir sonst zu falschen Schl√ºssen √ºber
unsere Kamele kommen w√ºrden.

### Gr√ºnde f√ºr Ausrei√üer

Nun ist es im Beispiel ziemlich eindeutig gewesen, welche Tiere/Werte
nicht zur Population geh√∂ren. In der Praxis ist es oft etwas
undeutlicher, aber zun√§chst zu den Gr√ºnden f√ºr Ausrei√üer:

-   Mess- oder ggf. Tippfehler
-   echter Ausrei√üer (Daten geh√∂ren nicht zur Population)

Auch hier ein Beispiel: Im Falle eines Fragebogens kann es z.B.
passieren, dass die Probanden eine Frage falsch verstanden haben. Wird
nach dem Geburtsjahr gefragt und du hast einige Antworten die
offensichtilich die Anzahl an Jahren sind (z.B: `61`) handelt es sich um
einen *Mess- bzw. Tippfehler*. Ist die Antwort hingegen `3050` k√∂nnen wir
davon ausgehen, dass der *Wert nicht zu unserer Population* geh√∂rt, da dies als Geburtsjahr nicht m√∂glich ist. Haben wir als Antwort jedoch den Wert `1920` ist dies zwar ein extremer Wert, aber m√∂glich w√§re es durchaus.

Wichtig f√ºr dich also: **Check your data!**

### Datenreinigung

Sieh dir nach dem Einlesen immer deine Daten an, scrolle durch die
Tabelle und suche nach Auff√§lligkeiten. Klicke daf√ºr in der Environment
auf deinen Datensatz und dort auf die einzelnen Variablennamen, um diese
auf- und absteigend anzeigen zu lassen. Auch die `summary()` Funktion
bietet sich f√ºr einen √úberblick √ºber deine Variablen an.

Damit sind wir auch schon beim Identifizieren und Behandeln von
Ausrei√üern. Fallen dir beim √úberpr√ºfen offensichtlich unm√∂gliche Werte
(aus dem Beispiel: `61` und `3050`) auf solltest du diese in "missing"
umcodieren. (Die `61` k√∂nnte sowohl 61 Jahre als auch Jahrgang 1961
bedeuten und sollte daher nicht h√§ndisch auf das entsprechende Geburtsjahr 
"korrigiert" werden.)

Aber was machen wir mit der `1920`? Ein Wert der zwar m√∂glich, aber
durchaus unplausibel (insbesondere f√ºr einen online Fragebogen)
erscheint.

Vielleicht erinnerst du dich aus dem Visualisierung Tutorial, daran,
dass wir z.B. Boxplots verwenden k√∂nnen, um Ausrei√üer zu identifizieren.
Der Boxplot basiert dabei auf der Annahme, dass alles was au√üerhalb
$1.5 \cdot IQR$ also 1.5x der L√§nge des Interquartilsabstands liegt, als
Ausrei√üer gewertet werden *kann*. Sei dir dabei jedoch bewusst, dass
dies nur *eine* m√∂gliche statistische Definition ist. Es gibt weitaus
mehr Verfahren zur mathematischen Identifikation und alle sind mehr und
weniger von zuf√§lligen Werten (1.5 IQR) bestimmt. Als weiterf√ºhrende
Literatur ist @leys2019 zu empfehlen. Generell beruhen diese Verfahren
alle auf der Annahme, dass diese Werte in unserer Verteilung einfach
sehr unwahrscheinlich sind.

Das Kriterium $1.5 \cdot IQR$ ist nichtsdestotrotz ein guter
Anhaltspunkt und findet viel Anwendung in der Literatur. Daher wollen auch wir es nutzen, um als Beispiel die Variable `weg` aus unserem Datensatz `einkaufen` zu bereinigen.

Boxplot **vor** dem Ausschluss von Ausrei√üern in `weg`:
```{r box_mit_ausr, echo = FALSE}
# Boxplot vor Ausschluss
ggplot(einkaufen, aes(y = weg))+
  geom_boxplot()
```

Code zum Ausschluss von Werten au√üerhalb der 1.5-fachen *IQR*:
```{r ausreisser1, exercise = TRUE, exercise.cap = "Ausrei√üer raus"}
# zuerst berechnen wir die Grenzwerte Q1 & Q3, sowie die L√§nge der IQR
Q1 <- quantile(einkaufen$weg, .25, na.rm=T)
Q3 <- quantile(einkaufen$weg, .75, na.rm=T)
IQR <- IQR(einkaufen$weg, na.rm=T)

# dann k√∂nnen wir diese benutzen, um ein Subset aus einkaufen zu filtern, bei dem diese Werte ausgeschlossen werden
no_outliers <- einkaufen |> 
  filter(weg > (Q1 - 1.5*IQR) & weg < (Q3 + 1.5*IQR))

# mit `nrow` k√∂nnen wir feststellen, wie viele Zeilen von einkaufen in no_outliers rausgefiltert wurden 
nrow(einkaufen) - nrow(no_outliers)
```


Boxplot **nach** dem Ausschluss von Ausrei√üern in `weg`:
```{r box_ohne_ausr}
# zuerst berechnen wir die Grenzwerte Q1 & Q3, sowie die L√§nge der IQR
Q1 <- quantile(einkaufen$weg, .25, na.rm=T)
Q3 <- quantile(einkaufen$weg, .75, na.rm=T)
IQR <- IQR(einkaufen$weg, na.rm=T)

# dann k√∂nnen wir diese benutzen, um ein Subset aus einkaufen zu filtern, bei dem diese Werte ausgeschlossen werden
no_outliers <- einkaufen |> 
  filter(weg > (Q1 - 1.5*IQR) & weg < (Q3 + 1.5*IQR))

# Boxplot nach Ausschluss
ggplot(no_outliers, aes(y = weg))+
  geom_boxplot()
```

**Ganz wichtig!**: Wenn du Daten ausschlie√üt solltest du das, inklusive
der Argumentation warum, **gut dokumentieren.** Im Normalfall sollte
bereits vor der Datenerhebung festgelegt werden, nach welchen Kriterien
Daten ausgeschlossen werden m√ºssen - damit nicht nachtr√§glich das
Ergebnis in eine bestimmte Richtung gelenkt wird.

In unserem Fall w√ºrdest du also berichten, dass nach
Ausrei√üerbeseitigung 20 Personen/bzw. Eintr√§ge ausgeschlossen
wurden.

::: gelb
Beachte, dass damit also auch **alle anderen Antworten der Personen
rausgefiltert** wurden und somit auch f√ºr andere Fragestellungen abseits
der Analyse des `weg`s wegfallen! Daher sollte ein Ausschluss gut begr√ºndet und notwendig sein.
:::


### NAs ausschlie√üen

Besonders in Frageb√∂gen kommt es oftmals dazu, dass Personen den
Fragebogen nach einer bestimmten Zeit abbrechen und somit viele `NA`s in unserem Datensatz entstehen. Da diese F√§lle f√ºr eine Analyse meist unbrauchbar sind, gibt es auch hier eine M√∂glichkeit unseren Datensatz davon zu "reinigen".

```{r narm, exercise = TRUE}
# nur rows mit weniger oder genau 50% NA Werten werden beibehalten
einkaufen[rowMeans(is.na(einkaufen)) <= .5,]
```

Doch auch hier ist wieder Vorsicht geboten. Der Schwellenwert (hier 50%) sollte im Vorhinein gut √ºberlegt sein und der **Auschluss der Daten gut dokumentiert und berichtet** werden!

```{r naquizz}
question_radio("Welchen Wert solltest du w√§hlen, wenn du m√∂chtest, dass nur Zeilen mit weniger als 20% NA-Werten beibehalten werden ",
                    answer("rowMeans(is.na(einkaufen)) <= .8,",
                           message = "Die Funktion vergleicht mit `<=` ob die Reihen jeweils weniger oder gleich 0.8 also 80% NAs enthalten"),
                    answer("rowMeans(is.na(einkaufen)) <= .2,",
                            correct = TRUE),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de"))
```

Mehr und ausf√ºhrlichere Infos zum Thema Ausrei√üer und wie du damit
verfahren solltest findest du auch
[hier.](https://statistikguru.de/r/ungepaarter-t-test-r/umgang-mit-ausreissern-2.html)

## Abschlussquiz

```{r abschlussquiz_01, echo = FALSE}
quiz(caption="Teste dein Wissen...", 
     
     question_radio("Aus welchem Paket kommt die Funktion filter()",
                    answer("`tidyr`",
                           message = "tidyr ist zwar auch aus dem tidyverse, aber die Funktion `filter()` ist aus dem `dplyr` Paket."),
                    answer("`dplyr`",
                            correct = TRUE),
                    answer("`ggplot`",
                            message = "`ggplot` ist zwar auch aus dem tidyverse, aber die Funktion `filter()` ist aus dem `dplyr` Paket."),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de")),
     
      question_radio("Welchen Effekt hat die Funktion group_by(data, x)",
                    answer("Sie z√§hlt die Kategorien unserer Daten anhand von `x`.",
                           message = "Nicht ganz, aber zusammen mit der Funktion `count()` l√§sst es sich bewerkstelligen."),
                    answer("Sie erstellt Kategorien anhand von `x`.",
                            correct = TRUE),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de")),
     
     question_radio("Mit welcher Funktion kannst du eine Teilmenge der Zeilen ausw√§hlen",
                    answer("Mit `group_by(data, variable)`.",
                           message = "Nicht ganz, da du mit group_by() die Daten nur gruppierst, aber keine Teilmenge erstellst."),
                    answer("Mit `select(data, variable)`.",
                           message = "Nicht ganz, aber mit select l√§sst sich eine Teilmenge der Spalten ausw√§hlen."),
                    answer("Mit `filter(data, bedingung)`.",
                            correct = TRUE),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de")),
     
      question_radio("Welchen Effekt hat die Funktion summarise(data, mean(x))",
                    answer("Sie gibt den Mittelwert von `x` aus.",
                           correct = TRUE),
                    answer("Sie gibt einen Vektor an Mittelwerten mit der L√§nge von `x` aus.",
                            message = "`summarize()` ist eine Zusammenfassungs-Funktion, eine Window-Funktion wie `mutate()` hingegen w√ºrde einen gleichlangen Vektor ausgeben."),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de")),
     
        question_radio("Welchen Effekt hat die Funktion mutate(data, mean(x))",
                    answer("Sie gibt den Mittelwert von `x` aus.",
                           message = "`mutate()` ist eine Window-Funktion, eine Zusammenfassungs-Funktion wie `summarise()` hingegen w√ºrde einen einzelnen Wert ausgeben."),
                    answer("Sie gibt einen Vektor an Mittelwerten mit der L√§nge von `x` aus.",
                            correct = TRUE),
                    allow_retry = TRUE,
                    random_answer_order = TRUE,
                    incorrect = random_encouragement("de"),
                    correct = random_praise("de"))
)
```

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

In diesem Tutorial hast du die grundlegenden Funktionen von `dplyr`
kennengelernt, einem leistungsstarken Paket f√ºr die Datenmanipulation in
R. Die wichtigsten Funktionen, darunter `select()`, `filter()`,
`mutate()`, `group_by()`, `summarise()` und `arrange()`, erm√∂glichen es
dir, Daten effizient zu selektieren, filtern, transformieren, gruppieren
und zusammenfassen.

Das Tutorial hat dir auch gezeigt, wie du Daten bereinigen kannst, indem
du Ausrei√üer identifizierst und entscheidest, ob und wie du sie aus
deiner Analyse ausschlie√üen solltest. Es wurde betont, dass die
Entscheidung, Datenpunkte auszuschlie√üen, auf einer fundierten
Beurteilung basieren sollte.

Zusammenfassend hast du sowohl praktische F√§higkeiten in der
Datenmanipulation mit `dplyr` erworben als auch ein Bewusstsein f√ºr die
Bedeutung der Datenreinigung und Ausrei√üererkennung entwickelt, um
robuste Analysen durchzuf√ºhren.

### Diese neuen Funktionen kennst du nun:

-   `rename()` l√§sst dich deine Variablen umbenennen.
-   `select()` erm√∂glicht es dir, Variablen anhand ihrer Namen
    auszuw√§hlen.
-   `filter()`, um F√§lle basierend auf ihren Werten auszuw√§hlen.
-   `summarise()`, fasst mehrere Werte zu einer einzigen Zusammenfassung
    zusammen.
-   `arrange()`, um die Reihenfolge der Zeilen zu √§ndern.
-   `group_by()`, um Funktionen gruppenweise durchzuf√ºhren.

### Neue Funktionen

| Code          | Beschreibung              |
|---------------|---------------------------|
| `rename()`    | Umbenennen von Variablen  |
| `select()`    | Auswahl von Variablen     |
| `filter()`    | Filtern von Datens√§tzen   |
| `mutate()`    | Erstellen neuer Variablen |
| `group_by()`  | Gruppierung von Daten     |
| `summarise()` | Zusammenfassung von Daten |
| `arrange()`   | Sortieren von Datens√§tzen |

## Hash generieren

Wenn du mit deinen Antworten im Tutorial zufrieden bist, generiere dir deinen Hash-Code, kopiere ihn und lade ihn bei der entsprechenden Abgabe auf Moodle hoch!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui(ui_before = NULL)
```

### [**Moodle-Kurs √∂ffnen**](https://moodle.uni-kassel.de/course/view.php?id=19918)


## Credit

Dieses Tutorial wurde von Marie Klosterkamp sowie in Teilen von Lukas
Bruelheide geschrieben.

Bei der Erstellung des Bildes wurde von Bing Image Creator gebrauch gemacht.

### Literaturverzeichnis

<!--  Wird automatisch generiert aus den @autorYYYY-Zitationen und der Bibliothek in ref.json. Das Literaturverzeichnis wird immer ans Ende generiert, deswegen muss das hier die letzte √úberschrift bleiben. -->
