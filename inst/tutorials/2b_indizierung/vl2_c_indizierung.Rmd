---
title: "Indizierung bei Vektoren"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
tutorial:
  id: indizierung
  version: 1
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Bestimmte Elemente eines Vektors ausw√§hlen
resource_files:
- css/boxes.css
---

```{r setup, include=FALSE}
library(learnr)
# library(gradethis)
set.seed(123)
knitr::opts_chunk$set(echo = FALSE)
```

## Inhalt

Dieses Tutorial f√ºhrt dich durch die Grundlagen der Indizierung in R. Erfahre, wie du gezielt auf Elemente in Vektoren zugreifen kannst, um deine Daten gezielt im Griff zu haben.

::: grau-nb
**Hinweis** Dieses Tutorial ist stark angelehnt an die `swirl`-Lektion [Subsetting Vectors](http://www.simonqueenborough.info/R/basic/intro-to-swirl) innerhalb des Kurses "R Programming".
:::

## Lernziele

In diesem Tutorial lernst du:

-   <input type="checkbox" unchecked> Wie du auf bestimmte Elemente in Vektoren zugreifst. </input>
-   <input type="checkbox" unchecked> Die Anwendung von ganzzahliger Indizierung </input>
-   <input type="checkbox" unchecked> Die Anwendung von logischer Indizierung </input>
-   <input type="checkbox" unchecked> Die Anwendung von textbasierter Indizierung </input>

## Indizierung

![](images/honeyguide.jpg "indicator indicator, by Wilferd Duckitt (CC BY 2.0)"){width="50%"}

###### Foto: Wilferd Duckitt (CC BY 2.0)

Der *Honeyguide* hat seinen lateinischen Namen *indicator indicator* aus guten Grund: Er ist ein Indikator, d.h. **Anzeiger** f√ºr den Ort von Bienennestern.

Dieser in Afrika vorkommende Vogel kennt sich gut aus und f√ºhrt aktiv Menschen zu den Nestern der Bienen. Die Menschen ernten den Honig und der *Honeyguide* bekommt eventuell etwas ab. ([wikipedia](https://en.wikipedia.org/wiki/Greater_honeyguide))

In diesem Tutorial geht es auch um das Anzeigen einer bestimmten Stelle, sogenanntes *Indizieren*.

Du hast bereits gelernt, wie Vektoren erstellt werden und dass sie mehrere Elemente hintereinander enthalten k√∂nnen. Jedes Element hat also eine Position. Im Folgenden lernst du, die Elemente anhand ihrer Position oder ihres Inhalts separat aufzurufen. Das hei√üt in R "Indizierung".

### verschiedene Arten der Indizierung

Es gibt insgesamt 3 verschiedene Arten:

1.  Indizierung mit ganzen Zahlen

```{r ganzzahlig, exercise = TRUE}
# Die ersten 6 Eintr√§ge der Spalte mpg 
mtcars$mpg[1:6] 
```

2.  Indizierung mit Logik

```{r logisch1, exercise = TRUE}
# Alle Autos, die mehr als 25 Meilen schaffen
mtcars$mpg[mtcars$mpg > 25] 
```

3.  Indizierung mit Text

```{r logisch2, exercise = TRUE}
# Wie weit kommt ein Honda Civic mit einer Gallone Treibstoff?
mtcars["Honda Civic", ]$mpg 
```


::: aufgabe
**\* Zusatzaufgabe:** Miles per gallon ist ein un√ºbliches und Ma√ü f√ºr uns.

a)  Rechnen Sie die Spalte `mpg` in eine neue Spalte `lp100km` um, die den Verbauch in Litern pro 100 km angibt!
b)  Wie viel Liter pro 100 km verbraucht der Honda Civic?
:::

```{r zusatz, exercise = TRUE}
# L/100km = 235.214583 / mpg
# angenommen, dass 1 Gallone = 3.78541 Liter 
mtcars$lp100km <- mtcars$mpg
```

```{r zusatz-solution}
# a)
mtcars$lp100km <- 235.214583 / mtcars$mpg

# b) 
mtcars["Honda Civic", ]$lp100km
```

```{r silentsetup}
mtcars$lp100km <- 235.214583 / mtcars$mpg
```

Das war ein kurzer √úberblick √ºber die drei verschiedenen Methoden. Es klingt jetzt erst mal technisch, ist es auch. Um R wirklich zu verstehen ist es einfach total hilfreich, zu wissen, wie Indizierung funktioniert, und welche verschiedenen Arten es gibt. Denn die drei verschiedenen Arten funktionieren alle √§hnlich, aber unterscheiden sich in ihrem Aufbau fundamental. Der n√§chste Abschnitt demonstriert das Konzept zun√§chst mit ganzzahligen Vektoren.

## Indizieren mit ganzzahligen Vektoren

### Anwendungsbeispiel

Der Vektor `x` enth√§lt 30 (hypothetische) Messungen einer Wetterstation. Lasse dir `x` anzeigen!

```{r ex}
x <- c(22, 25, 23, 19, 20, 23, 25, 27, 29, 24, rep(1000, 20))
```

```{r x, exercise = TRUE, exercise.setup = "ex"}

```

Du siehst bereits das Problem: Die letzten 20 Werte sind fehlerhaft, weil das Messinstrument nicht richtig funktioniert hat. Wie k√∂nnen wir also nur die ersten 10 Werte ausw√§hlen?

Daf√ºr ben√∂tigen wir eine neue Funktion, den sogenannten *index operator* `[]`.

```{r ex2, exercise = TRUE, exercise.caption = "Index Operator", exercise.setup = "ex"}
x[1:10]
```

Innerhalb der eckigen Klammern wird ein Vektor angegeben. In diesem Fall die Zahlenreihe `1:10`, um die ersten 10 Elemente auszuw√§hlen.

::: grau
#### Verbalisierung

`[]` kann gelesen werden als: "*An der Stelle...*".

Beispiele:\
`x[9]` = `x` *an der Stelle* 9

`x[1:10]` = `x` *an den Stellen* 1 bis 10
:::

Jetzt bist du gefragt:

::: aufgabe
**1.** W√§hle nur die 7. Messung aus!
:::

```{r choose-solution}
x[7]
```

```{r choose, exercise = TRUE, exercise.setup = "ex"}
x[]
```

<details>

<summary><a>‚ñº \* Exkurs: One-based-counting</a></summary>

::: infobox
Viele Programmiersprachen basieren auf *zero-based-counting*, das hei√üt, das Z√§hlen der Elemente beginnt bei 0. Falls Sie bereits Erfahrung mit einer solchen Sprache haben, m√ºssen Sie sich nun umgew√∂hnen, denn R hingegen verwendet *one-based-counting*. Dabei bekommt das erste Element auch tats√§chlich die Nummer 1.
:::

</details>

<br>

::: aufgabe
**2.** Lasse dir nur die Messung von Tag 5 und Tag 2 ausgeben!
:::

```{r selective, exercise = TRUE, exercise.setup = "ex"}
x[]
```

::: {#selective-hint}
Innerhalb von `[]` kann ein Vektor stehen, der die Positionen der auszuw√§hlenden Elemente enth√§lt.

Mehrere Zahlen werden mit `c()` zu einem Vektor verkn√ºpft.
:::

```{r selective-solution}
x[c(5, 2)]
```

::: aufgabe
**3.** Lasse dir die Buchstaben in der Reihenfolge `c`, `b`, `a` mittels Indizierung ausgeben!
:::

```{r indexing, exercise = TRUE}
# Definieren eines Vektors 'abc'
abc <- c("a", "b", "c")

# Indizierung:
abc[]      
```

```{r indexing-solution}
abc[3:1]
# oder
abc[c(3, 2, 1)]
```

In diesem Fall werden drei Elemente ausgew√§hlt. Zu erst die dritte Stelle von `abc`, welche "c" lautet, dann die zweite ("b") und dann die erste ("a").

So langsam hast du vermutlich verstanden, wie es funktioniert. Hier sind noch ein paar √úbungsaufgaben:

::: aufgabe
**4.** Lasse dir das zweite und das dritte Element von `abc` ausgeben!
:::

```{r application-setup}
abc <- c("a", "b", "c")
```

```{r application, exercise = TRUE}
abc[]
```

::: {#application-hint}
Innerhalb von `[]` kann ein Vektor stehen, der die Positionen der auszuw√§hlenden Elemente enth√§lt.

Mehrere Zahlen werden mit `c()` zu einem Vektor verkn√ºpft.
:::

```{r application-solution}
abc[c(2, 3)]
```

::: aufgabe
**5.** W√§hle nur das erste Element aus `abc` aus und speichere das Ergebnis in einem neuen Objekt `a`!

Lasse dir `a` ausgeben, um zu sehen ob es funktioniert hat.
:::

```{r a-setup}
abc <- c("a", "b", "c")
```

```{r a-solution}
a <- abc[1]
a
```

```{r a, exercise = TRUE}
abc[]
```

<details>

<summary><a>‚ñº \* Zusatzwissen: Ausschluss von Daten anhand negativer Zahlen</a></summary>

::: infobox
Mit negativen Zahlen k√∂nnen bestimmte Elemente ausgeschlossen werden.

```{r neg, exercise = TRUE, exercise.setup = "ex"}
x[-(10:20)]   # schlie√üt Messung 10 bis 20 aus. 
```
:::

</details>

<br>

::: gelb
#### Gut zu wissen

Die Konsole nutzt auch die Index-Schreibweise, um langen Output zu strukturieren: Zu Beginn jeder neuen Zeile ist die Nummer des ersten Elements der Zeile in eckigen Klammern angegeben.

```{r, echo=TRUE}
1:60
```
:::

### Zusammenfassung

Sehr gut! In diesem Abschnitt hast du gelernt, wie Indizierung mit Zahlenvektoren funktioniert. Das ist nur einer von drei m√∂glichen Wegen. Im n√§chsten Abschnitt wirst du lernen, mittels **logischer Vektoren** zu indizieren.

## Indizierung mit logischen Vektoren

Bisher hast du Indexierung mit Zahlenvektoren kennengelernt. Wie du im Tutorial "Vektoren" gelernt hast, gibt es auch logische Vektoren, die auch zur Indizierung genutzt werden k√∂nnen. Die sehen so aus:

```{r logidemo, exercise = TRUE}
c(TRUE, FALSE, TRUE)
```

Eine Indizierung mit logischen Vektoren sieht entsprechend so aus:

```{r logindex-setup}
abc <- c("a", "b", "c")
```

```{r logindex, exercise = TRUE}
abc[c(TRUE, FALSE, TRUE)]
```

```{r logiquestion}
question("Was k√∂nnen Sie daraus ableiten?",
  answer("√úberall dort, wo FALSE steht, wird ein Element ausgew√§hlt"),
  answer("An allen Positionen, wo TRUE steht, wird ein Element ausgew√§hlt", 
    correct = TRUE),
  answer("Indizierung mit logischen Vektoren ist unlogisch"),
  allow_retry = TRUE
)
```

### Bedingungspr√ºfungen

Generell entstehen logische Vektoren bei **Bedingungspr√ºfungen**.

Beispielsweise k√∂nnten wir pr√ºfen, welche Wettermessungen in `x` *nicht* den fehlerhaften Wert 1000 enthalten.

```{r condi, exercise = TRUE, exercise.setup = "ex"}
x != 1000
```

Dieser Code pr√ºft f√ºr jedes Element von `x`, ob es der Bedingung "ungleich 1000" entspricht. Das Ergebnis wird als logischer Vektor ausgegeben. Nur die ersten 10 Elemente sind TRUE, w√§hrend die letzten 20 Elemente FALSE sind.

::: blau-nb
#### Vergleichsoperatoren

Diese Vergleichsoperatoren gibt es in R:

-   `<` und `>` : kleiner / gr√∂√üer als
-   `<=` und `>=`: kleiner gleich / gr√∂√üer gleich
-   `==`: gleich (Achtung, `=` hat eine ganz andere Bedeutung)
-   `!=`: ungleich (bzw. nicht gleich)
-   `!x`: nicht x  
:::

<br>

::: aufgabe
**Anwendungsaufgabe**

Stelle Bedingungspr√ºfungen auf, in denen `x` gepr√ºft wird auf...

a)  Werte die $\leq 25$ sind.
b)  Werte $= 25$
c)  Werte $\geq 25$
:::

```{r leq, exercise = TRUE, exercise.setup = "ex"}
x
```

```{r leq-solution}
# a)
x <= 25

# b) 
x == 25

# c)
x >= 25
```

Perfekt! Du bist nun gewappnet, um mit Bedingungspr√ºfungen zu indizieren.

### Indizierung

Wir m√∂chten nun alle Elemente von `x` ausw√§hlen, die ungleich 1000 sind.

```{r neq, exercise = TRUE, exercise.setup = "ex"}
x[x != 1000]  # Indizieren mit Bedingungspr√ºfung
```

::: grau
#### Verbalisierung

Lies: `x[x != 1000]` = `x` *an der Stelle wo* "`x` ungleich 1000"
:::

<br> Hinter den Kulissen wird zuerst die Bedingungspr√ºfung `x != 1000` evaluiert, denn Code wird immer von innen nach au√üen ausgef√ºhrt.

Das Ergebnis der Pr√ºfung ist ein logischer Vektor:

```         
TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
```

Dann findet die Indizierung mittels dieses logischen Vektors statt.

Als Ergebnis erhalten wir alle Elemente von `x`, die ungleich 1000 sind.

```         
[1] 22 25 23 19 20 23 25 27 29 24
```

### √úbungsaufgaben

Jetzt bist du dran:

::: aufgabe
**1.** Lasse dir die Messungen in `x` ausgeben, die kleiner als 20 sind!
:::

```{r filter, exercise = TRUE, exercise.setup = "ex"}
x[]
```

```{r filter-solution}
x[x < 20]
```

::: aufgabe
**2.** Mit der Funktion `rnorm()` k√∂nnen wir $n$ zuf√§llige Ziehungen aus einer Standardnormalverteilung simulieren.

a)  Lasse dir `x` anzeigen!

b)  Lasse dir nur die Elemente anzeigen, die gr√∂√üer als 0 sind.
:::

```{r rnorm-solution}
x        # Anzeigen
x[x > 0] # Nur Werte > 0 anzeigen
```

```{r rnorm, exercise = TRUE}
x <- rnorm(100)  # Ziehung von 100 Werten
```

### Verkn√ºpfung von Bedingungen

Nun hast du bereits Vergleichsoperatoren kennengelernt, um Bedingungspr√ºfungen zu erstellen. Was ist aber, wenn ich zwei Bedingungspr√ºfungen verkn√ºpfen m√∂chte?

#### Indizierung mit logischen Vektoren: UND ( & ) und ODER ( \| )

Wir haben bereits gelernt, wie wir logische Vektoren f√ºr die Indizierung verwenden k√∂nnen. Jetzt schauen wir uns an, wie wir mehrere Bedingungen kombinieren k√∂nnen.

-   Der UND-Operator (`&`): Wird verwendet, wenn beide Bedingungen *gleichzeitig erf√ºllt* sein m√ºssen.
-   Der ODER-Operator (`|`): Wird verwendet, wenn *mindestens eine* der Bedingungen *erf√ºllt* sein muss.

#### Anwendungsaufgabe:

Nehmen wir wieder unseren Vektor, der Temperaturen von der Wetterstation darstellt, diesmal wurden auch einige extremere Temperaturen aufgezeichnet. Nun m√∂chten wir alle Temperaturen √ºber `25` und unter `30` extrahieren, um zu schauen an welchen Tagen wir gutes Badewetter hatten. 

```{r Operators, exercise = TRUE}
# Erstellung eines Beispielvektors temperature
temperature <- c(23, 26, 24, 28, 22, 30, 18, 27, 25, 22, 0, 45, 2, 5, -2, 11, 16, 42)

# Subset erstellen: Temperaturen zwischen 25 und 30
selected_temperatures <- temperature[temperature > 25 & temperature < 30]
selected_temperatures # Ausgabe der Temperaturen
```

##### Gut zu wissen:
Durch das Speichern des Idizierungsergebnisses in einer Variable mittels des *assignment operators* `<-` wird hier ein *Subset* erstellt, welches nur die Temperaturen enth√§lt, die sowohl √ºber 25 als auch unter 30 liegen. 

::: blau-nb
Ein Subset ist dabei nichts anderes als eine Teilmenge von Daten, die durch die Auswahl bestimmter Elemente aus einem gr√∂√üeren Datensatz gebildet wird. In unserem Fall ist `selected_temperatures` also ein Subset von `temperature`. Dank des Subsets ist es dann m√∂glich, nur mit einer Teilmenge der urspr√ºnglichen Daten weiterzurechnen. 
:::

#### √úbungsaufgabe: 

Jetzt bist du dran:

::: aufgabe
Verwende den Vektor `temperature` und lasse dir alle Temperaturen √ºber 26 sowie unter 20 mit Hilfe des ODER-Operators ausgeben.
:::

```{r Ops1, exercise = TRUE, exercise.setup = "Operators", exercise.cap = "Temperaturen > 20 ODER < 26"}
temperature[]
```

```{r Ops1-solution}
# Vom Vektor temperature nimm alle Temperaturen, die unter 20 ODER √ºber 26 liegen
temperature[temperature > 26 | temperature < 20]

```

#### Zum Ausprobieren:

Was denkst du passiert, wenn wir anstelle des ODER-Operators in der letzten Aufgabe den UND-Operator genutzt h√§tten? Probiere es hier gerne aus indem du den Operator wechselst:

```{r Ops2, exercise = TRUE, exercise.setup = "Operators", exercise.cap = "Zum Herausfinden" }
temperature[temperature > 26 | temperature < 20]
```

```{r Ops2-solution}
# alle Temperaturen des Vektors temperature, die unter 20 UND √ºber 26 liegen
temperature[temperature > 26 & temperature < 20]
# Das Ergebnis ist ein leeres Subset, da Temperaturen nicht gleichzeitig √ºber 26 und unter 20 sein k√∂nnen. R gibt also ein leeres Subset `numeric(0)` zur√ºck.
```

F√ºr die Erkl√§rung kannst du den `L√∂sung`s-Knopf dr√ºcken.

Super! Du hast diese wichtige Art von Indizierung gemeistert.

## Indizierung mit Textvektoren

In den vorherigen Abschnitten hast du gelernt, wie du numerische Vektoren mithilfe von Indizierung und logischen Operatoren filtern kannst. Jetzt werfen wir noch einen Blick auf die Indizierung von Textvektoren.

### Benannte Vektoren

Benannte Vektoren sind eine M√∂glichkeit, Werte in einem Vektor mit entsprechenden Namen zu versehen. Statt nur numerische Indizes zu verwenden, kannst du jedem Element im Vektor einen leicht verst√§ndlichen Namen zuweisen. Zum Beispiel:

```{r bV, exercise = TRUE}
grades <- c("Alice" = 1.0, "Bob" = 2.3, "Charlie" = 1.7, "David" = 3.3, "Eve" = 2.7)
grades
```

Hier sind die Namen ("Alice", "Bob", usw.) den jeweiligen Noten zugeordnet. Dies erm√∂glicht eine einfachere und intuitivere Indizierung. 

Wenn du beispielsweise die Note von "Bob" abrufen m√∂chtest, kannst du dies direkt mit `grades["Bob"]` tun.

```{r bV1, exercise = TRUE, exercise.setup = "bV"}
grades["Bob"]
```

Benannte Vektoren sind besonders n√ºtzlich, wenn du Daten hast, bei denen es sinnvoll ist, jedem Element einen aussagekr√§ftigen Namen zuzuordnen, wie im Beispiel der Studierenden und ihren Noten.

### Beispiel:

Angenommen, wir haben einen Vektor von Temperaturen, die verschiedenen Monaten zugeordnet sind:

```{r bV2, exercise = TRUE}
# Erstellung eines benannten Vektors f√ºr Temperaturen
temperature <- c("Januar" = 23, 
                 "Februar" = 26, 
                 "M√§rz" = 24, 
                 "April" = 28, 
                 "Mai" = 22)
temperature
```

Jeder numerische Wert bekommt hier also einen benennenden *character* Wert zugewiesen. Das siehst du auch schon bei der Darstellung der Variable, bei der das Wertpaar aus *character* und *numeric* untereinander darstellt wird.

::: infobox
F√ºr den Fall, dass eine Funktion mehrere benannte Argumente hat, ist es guter Stil, jedes auf eine neue Zeile zu setzen. RStudio r√ºckt die Elemente automatisch so weit ein, das klar ist, wo sie hingeh√∂ren. 

Wie Variablennamen sollten auch benannte Vektoren nur einmal im Datensatz existieren. Wird ein benannter Vektor mehrmals verwendet, f√ºhrt dies zu Problemen. Wollen wir oder R dann mittels `[]`Indizierung auf die Daten zugreifen, so wird stets nur der erste Treffer ausgegeben. 
:::

<br>

Aber falls du Lust hast, kannst du nat√ºrlich auch selbst mal ausprobieren was passiert, wenn du oben in dem Beispiel mit den Namen experimentierst oder auch einem Namen mehrere numerische Werte als Vektor zuordnest.

In diesem Beispiel sind also die Temperaturen den Monaten zugeordnet. Jetzt k√∂nnen wir den Vektor anhand unserer benannten Vektoren filtern:

```{r bV3, exercise = TRUE, exercise.setup = "bV2" }
# Filtern von Temperaturen f√ºr M√§rz und April
temperature[c("M√§rz", "April")] # wir ben√∂tigen hier wieder den `c( )` Befehl, um die beiden Eintr√§ge als ein Argument in die Funktion zu f√ºttern.
```

### √úbungsaufgabe

::: aufgabe
Erstelle einen benannten Vektor `days_in_month` f√ºr die Monate `Januar` bis `Mai` und f√ºlle sie mit den Werten `31, 28, 31, 30, 31`. Rufe dann die Anzahl der Tage f√ºr den Monat April ab.
::: 
```{r bV4-solution}
days_in_month <- c("Januar" = 31, "Februar" = 28, "M√§rz" = 31, "April" = 30, "Mai" = 31)
days_in_month["April"]
```

```{r bV4, exercise = TRUE}

```

Auch diese Indizierungsvariante hast du nun mit Bravour gemeister! Super gemacht! Weiter gehts mit einer letzten √úbungsaufgabe, damit du pr√ºfen kannst, was du heute gelernt hast.

## Anwendungsaufgabe

Versuche die im Tutorial gelernten Konzepte anzuwenden:

::: aufgabe
a.  Erstelle eine absteigende Zahlenreihe von `100 bis 1`. Gib der Reihe den Namen `x`.

b.  Addiere das dritte und siebte Element des Vektors `x`! Benenne das Ergebnis mit `y`.

c.  Lasse dir `y` ausgeben.
:::

```{r anw-hint}
# Zahlenreihen r√ºckw√§rts: die h√∂here Zahl nach vorne stellen.
# Addieren ganz simpel mit `+`
```

```{r anw-solution}
x <- 100:1
y <- x[3] + x[7]
y
```

```{r anw, exercise = TRUE, exercise.caption = "Indizierung"}

```

Gut gemacht! So kann es weitergehen! üöÄ


::: grau-nb
Hinweis: Falls beim Wert von `y` ein `L` dahinter steht, ist v√∂llig normal. Das `L` steht f√ºr *Long* und bezeichnet einen Datentyp.
:::

## Abschlussquiz

Lass uns noch schnell dein Wissen anhand von Quizzfragen testen! Bist du bereit? 

Los gehts:

```{r abschlussquiz_01}
question_checkbox("Wie w√§hlt man die Elemente 5 bis 8 eines Vektors aus?",
         answer("vector[5, 8]", correct = FALSE),
         answer("vector[c(5, 8)]", correct = FALSE),
         answer("vector[5:8]", correct = TRUE),
         answer("vector[-(5:8)]", correct = FALSE),
         allow_retry = TRUE
         )
```

```{r abschlussquiz_02}
question_checkbox("Wie erstellt man einen logischen Vektor, der TRUE f√ºr Werte gleich 30 ist?",
         answer("logical_vector <- numeric_vector > 30", correct = FALSE),
         answer("logical_vector <- numeric_vector == 30", correct = TRUE),
         answer("logical_vector <- numeric_vector < 30", correct = FALSE),
         answer("logical_vector <- numeric_vector >= 30", correct = FALSE),
         allow_retry = TRUE
         )
```


```{r abschlussquiz_03}
question_checkbox("Was ist f√ºr die Erstellung eines benannten Vektors zu beachten?",
         answer("Die Eintr√§ge m√ºssen Zahlen sein.", correct = FALSE),
         answer("Der Vektor darf keine Namen haben.", correct = FALSE),
         answer("Die L√§nge der Eintr√§ge muss gleich der Anzahl der Namen sein.", correct = TRUE),
         answer("Es ist wichtig, unverwechselbare Namen f√ºr die Eintr√§ge zu haben.", correct = TRUE),
         allow_retry = TRUE
         )


```

## Learnings heute

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Herzlichen Gl√ºckwunsch! üéâ Du hast heute erfolgreich das Tutorial zur Indizierung in R abgeschlossen. Hier sind die wichtigsten Punkte, die du gelernt hast:

- Indizierung mit numerischen Vektoren: Du wei√üt jetzt, wie du bestimmte Elemente eines numerischen Vektors anhand ihrer Position ausw√§hlen kannst. Daf√ºr haben wir den Index-Operator [] verwendet und sind verschiedene Beispiele durchgegangen.

- Indizierung mit logischen Vektoren: Du kennst nun die Verwendung von logischen Vektoren f√ºr die Indizierung. Dabei haben wir die UND (&) und ODER (|) Operatoren behandelt, um Bedingungen zu kombinieren und spezifische Daten auszuw√§hlen.

- Indizierung mit Textvektoren: Wir haben benannte Vektoren eingef√ºhrt, die es dir erm√∂glichen, Elemente anhand ihrer Namen auszuw√§hlen. Das er√∂ffnet dir neue M√∂glichkeiten, Daten zu filtern und gezielt auf bestimmte Informationen zuzugreifen.

### Diese neuen Konzepte kennst du nun:

-   numerische Indizierung

-   logische Indizierung

-   Benannte Vektoren

-   Indizierung mittels benannter Vektoren


### Neue Funktionen

| Code           | Beschreibung                           |
|----------------|----------------------------------------|
| `[ ]`          | Indizierung                            |
| `&`            | UND-Operator f√ºr logische Indizierung  |
| `|`            | ODER-Operator f√ºr logische Indizierung |
| `<` und `>`    | kleiner / gr√∂√üer als                   |
| `<=` und `>=`  | kleiner gleich / gr√∂√üer gleich         |
| `==`           | gleich                                 |
| `!=`           | ungleich                               |

#### F√ºr die Indizierung:

| Code           | Beschreibung                                |
|----------------|---------------------------------------------|
| `x[4]`         | Das vierte Element.                         |
| `x[-4]`        | Alles au√üer das vierte Element.             |
| `x[2:4]`       | Elemente zwei bis vier.                     |
| `x[-(2:4)]`    | Alle Elemente au√üer zwei bis vier.           |
| `x[c(1, 5)]`   | Elemente eins und f√ºnf.                     |
| `x[x == 10]`   | Elemente, die gleich 10 sind.               |
| `x[x < 0]`     | Alle Elemente kleiner als Null.             |
| `x['apple']`   | Element mit dem Namen 'apple'.              |

Du hast heute wichtige Grundlagen f√ºr die Arbeit mit Daten in R gelernt. Jetzt bist du bestens ger√ºstet, um deine Daten effizient zu durchsuchen, zu filtern und gezielt zu verwenden. Weiter so! üëèüöÄ

## Credits
Dieses Tutorial wurde (gr√∂√ütenteils) von Lukas Bruelheide sowie in Teilen von Marie Klosterkamp geschrieben. Bei der Erstellung (u.a. der Beispiele, Aufgaben und Zusammenfassung) wurde teilweise von ChatGPT gebrauch gemacht.

