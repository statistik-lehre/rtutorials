---
title: "Dispersionsmaße"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Varianz, Standardabweichung
resource_files:
- css/boxes.css
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
x <- c(1, 1, 9, 3, 6)
```

```{r ex}
x <- c(1, 1, 9, 3, 6)
```

<!-- @Lukas muss hier vlt das Paket shinywidgets noch installiert werden? Bei mir lässt sich das Dokument sonst nicht rendern -->

## Intuition bekommen

### Was ist Streuung?
```{r ui}
            sliderInput("var",
                        "Varianz",
                        min = 0,
                        max = 50,
                        value = 5,
                        step = 0.1)

           plotOutput("distPlot")
```

```{r server, context = "server"}
 output$distPlot <- renderPlot({
       set.seed(1)
       y <- rnorm(5000, sd = sqrt(input$var))
       df <- data.frame(x = 1:5000, y)
       ggplot(df, aes(x, y)) +
         geom_hline(yintercept = 0, col = "blue") +
         geom_point(alpha = .4) +
         theme_void() +
         coord_cartesian(xlim = c(1, 5000), ylim = c(-25, +25))


    })
```

In den nächsten Kapiteln gehen wir der Frage nach, wie Streuung messbar gemacht werden kann. 

## Spannweite
Das einfachste Maß, um die Ausdehnung von Daten zu bestimmen, ist vermutlich das Minimum und Maximum.
Daraus ergibt sich dann die Spannweite (*range*).

Wir arbeiten mit Beispieldaten, die auch in der Vorlesung verwendet wurden:

```
x <- c(1, 1, 9, 3, 6)
```

```{r range}
y <- c(1, 1, 9, 3, 6)

df <- data.frame(x = 1:5, y = y)
ggplot(df, aes(x, y)) +
  geom_point(size = 3) +
  geom_segment(aes(x = 2.5, xend = 2.5, y = 1, yend = 9), 
               arrow = arrow(ends = "both", type = "closed", length = unit(0.1, "inches")),
               col = "red")+
  geom_label(label = "Range\n= 8", aes(x = 2.5, y = 5)) +
  scale_y_continuous(breaks = 0:10) +
  scale_x_continuous(breaks = NULL) +
  theme_bw() +
  labs(x = "", y = "x")
```

#### Umsetzung in R

::: aufgabe 
**1.**

Obwohl es in diesem Fall auch ohne Computer sehr überschaubar ist: verwenden Sie die R-Funktion
`range()`, um Minimum und Maximum zu bestimmen!
:::

```{r range_exercise, exercise = TRUE, exercise.setup = "ex"}
range(x)
```

Als Ergebnis steht ein Vektor mit zwei Zahlen: die erste bezeichnet das Minimum, die zweite das Maximum.

::: aufgabe
**2.**

Um nun die Spannweite zu berechnen, müssen wir $Max - Min$ rechnen. Das geht für dieses Beispiel im Kopf, aber wir üben ja für die schweren Fälle - deswegen nehmen wir wieder eine R-Funktion zu Hilfe: `diff()` um die Differenz zu berechnen. 

Füttern Sie `diff()` mit dem Vektor, der durch `range(x)` ausgegeben wird.
:::

```{r range2, exercise = TRUE, exercise.setup = "ex"}
range(x)
```

```{r range2-solution}
diff(range(x))
```
```{r questionaes}
question_checkbox("Welches Skalenniveau muss mindestens vorhanden sein, um das Minimum und Maximum bestimmen zu können?",
                  answer("Nominal", message = "leider falsch, nominale Daten haben keine Reihenfolge"),
                  answer("Ordinal", correct = T, message = "ordinale Daten haben eine Reihenfolge"),
                  answer("Metrisch", message = "metrische Daten haben nicht nur eine Reihenfolge, sondern auch Abstände, die interpretierbar sind, was für Minimum und Maximum nicht nötig ist."))
```

```{r questionaes2}
question_checkbox("Welches Skalenniveau muss mindestens vorliegen, um die Spannweite zu berechnen?",
                  answer("Nominal", message = "Leider falsch, nominale Daten haben keine Abstände"),
                  answer("Ordinal", message = "Ordinale Daten haben leider keine Information über Abstände, weswegen das Bilden der Differenz zwischen Maximum und Minumum „illegal“ ist."),
                  answer("Metrisch", correct = T, message = "Genau! Nur metrische Daten enthalten Informationen über Abstände."))
```

## Varianz & Standardabweichung

### Streuung als Abweichung von einem Zentrum

Es ist ein einfaches und geniales Konzept: 

Streuung wird gemessen durch die gesamte Abweichung aller Werte von einem Zentrum.

Das Zentrum ist meistens der Mittelwert, aber es gibt auch weniger gebräuchliche Maße, die z.B. den Median als Zentrum verwenden. Wir fokussieren uns jetzt aber auf die Abweichungen vom Mittelwert, weil das das Fundament für Varianz, Standardabweichung, Korrelation und Regression ist!

### Abweichungen vom Mittelwert

In Rot sehen sie den Abstand jedes einzelnen Werts zum Mittelwert.

```{r deviance}
y <- c(1, 1, 9, 3, 6)
res <- y - mean(y)
df <- data.frame(x = 1:5, y = y, res = res, meanres = (y + mean(y)) / 2)
ggplot(df, aes(x, y)) +
  geom_hline(yintercept = mean(y), color = "blue") +
  geom_linerange(aes(ymin = mean(y), ymax = y), color = "red") +
  geom_point(size = 3) +
  geom_label(label = res, aes(x = x + 0, y = meanres)) +
  scale_y_continuous(breaks = 0:10) +
  scale_x_continuous(breaks = NULL) +
  theme_bw() +
  labs(x = "", y = "x")
```


Die Abstände ergeben sich, wenn man den Mittelwert von jedem einzelnen Wert abzieht: 

$\large x_i - \bar x$

+-----------------+----------+----------+----------+----------+----------+
| $x_i$           | 1        | 1        | 3        | 6        | 9        |
+=================+=========:+=========:+=========:+=========:+=========:+
| $\bar{x}$       | 4        | 4        | 4        | 4        | 4        |
+-----------------+----------+----------+----------+----------+----------+
| $x_i - \bar{x}$ | -3       | -3       | -1       | 2        | 5        |
+-----------------+----------+----------+----------+----------+----------+

: Abweichungen vom Mittelwert

#### wichtige Eigenschaft des Mittelwerts

Interessanterweise ist der Mittelwert so definiert, dass sich die Abweichungen gegenseitig aufheben, wenn man sie alle addiert:

$$
{\large \sum_{i=1}^{n}{(x_i - \bar{x})}=0}
$$



Die Werte in der letzten Zeile stellen die Abweichungen vom Mittelwert dar. Wenn alle Werte der letzten Zeile addiert werden, kommt tatsächlich 0 heraus.

Das liegt an der Definition des Mittelwertes: Er liegt immer so, dass die negativen und die positiven Abweichungen sich gegenseitig aufheben.

Wie sähe eine mögliche Prüfung dieser Hypothese in R aus?


### Abweichungen vom Mittelwert berechnen

Um die Abweichungen vom Mittelwert ( $x_i - \bar{x}$ ) zu berechnen, wird der Mittelwert `mean(x)` von jedem einzelnen Wert des Vektors `x` abgezogen. Tatsächlich ist das in R so einfach, dass es fast nicht zu glauben ist - R's Mächtigkeit im Umgang mit Vektoren lässt grüßen!

```{r, echo=TRUE}
x - mean(x)
```

Als Ergebnis entsteht ein neuer Vektor mit den Abweichungen vom Mittelwert.

Jetzt sind Sie selber gefragt!

::: aufgabe
**Anwendungsaufgabe**

Prüfen Sie, ob die Summe aller Abweichungen vom Mittelwert wirklich 0 beträgt.

Übersetzen Sie dazu die Formel $\sum{(x_i - \bar{x})}=0$ in R Code!

Denken Sie an Ihre bereits erlangten Kenntnisse der letzten Tutorials.
:::

```{r deviation-setup}
x <- c(1, 1, 9, 3, 6)
```

```{r deviation-solution}
sum(x - mean(x)) == 0
```

```{r deviation-hint}
# Verwenden Sie sum() für die Formel und für die Überprüfung == 0 
```

```{r deviation, exercise=TRUE, exercise.setup = "deviation-setup", exercise.caption = "Abweichungen vom Mittelwert"}

```

Super! Aber das war erst der halbe Weg - Wie Sie sehen, heben sich die Abweichungen gegenseitig auf, und wir müssen noch etwas dagegen unternehmen, um zu einem sinnvollen Maß für die Streuung zu kommen. 

### Quadratsummen

Da die Abweichungen vom Mittelwert summiert immer 0 ergeben, geht ihr Informationsgehalt über die Streuung leider verloren. Um ein Maß für die Streuung (auch Dispersion genannt) zu erhalten, müssen noch zwei weitere Schritte geschehen:

Um zu verhindern, dass sich positive und negative Abweichungen aufheben, werden die einzelnen Abweichungen von Mittelwert quadriert. Das bringt den Vorteil mit sich, dass am Ende eine substantielle Kennzahl für die Streuung steht, aber auch den Nachteil, dass Extremwerte durch die Quadrierung sehr stark ins Gewicht fallen.\
Die Summe der quadrierten Abweichungen vom Mittelwert heißt Quadratsumme.

$$
{\large QS=\sum{(x_i-\bar{x})^2}}
$$

```{r deviance2, fig.height=5, fig.width=5, message=FALSE, warning=FALSE}
df$y2 <- df$y
df$y2[2] <- NA
df$yno2 <- df$y
df$yno2[-2] <- NA
df$res2 <- df$res
df$res2[2] <- NA
df$resno2 <- df$res
df$resno2[-2] <- NA

ggplot(df, aes(x, y)) +
  geom_rect(aes(ymin = mean(y), ymax = y2, xmin = x, xmax = x - abs(res)), fill = "pink", alpha = .6, col = "darkred") +
  geom_label(label = df$res2^2, aes(x = (x + (x - abs(res))) / 2, y = meanres)) +
  geom_rect(aes(ymin = mean(y), ymax = yno2, xmin = x, xmax = x - abs(res)), fill = "pink", alpha = .6, col = "darkred") +
  geom_label(label = df$resno2^2, aes(x = (x + (x - abs(res))) / 2, y = meanres)) +
  geom_point(size = 3) +
  geom_hline(yintercept = mean(y), color = "blue") +
  scale_y_continuous(breaks = 0:10) +
  scale_x_continuous(breaks = NULL) +
  theme_bw() +
  labs(x = "", y = "x")
  
```

+---------------------+---------:+---------:+---------:+---------:+---------:+
| $x_i - \bar{x}$     | -3       | -3       | 5        | -1       | 2        |
+---------------------+----------+----------+----------+----------+----------+
| $(x_i - \bar{x})^2$ | 9        | 9        | 25       | 1        | 4        |
+---------------------+----------+----------+----------+----------+----------+

: Quadrierte Abweichungen vom Mittelwert

<br>
$QS = 9 + 9+25+1+4=48$

Die Quadratsumme in unserem Beispiel beträgt 48. Mehr als die Hälfte dieses Werts (25) wurde durch einen einzigen Ausreißer verursacht.

#### Quadratsummen vergleichbar machen

Das Problem mit Quadratsummen ist: Sie sind nicht wirklich vergleichbar. Je mehr Daten wir haben, desto größer wird die Quadratsumme. Wir müssen also den Einfluss der Stichprobengröße herausrechnen, um ein vergleichbares Maß der Streuung zu erhalten.

Dafür teilen wir die Quadratsumme noch durch $n - 1$. 

$n$ ist hierbei die Stichprobengröße und davon ziehen wir $1$ *Freiheitsgrad* ab. Die Erklärung von Freiheitsgraden führt zu weit an dieser Stelle. Aber es hat sich einfach gezeigt, dass man bessere Schätzungen erhält, wenn man sie mit berücksichtigt. 

Nachdem:

- die Höhe der Abweichungen quantifizierbar ist
- und der Einfluss der Stichprobengröße herausgenommen wurde

sind wir bei der Formel für die Varianz angelangt!

### Varianz 

$$
{\large s^2 = {\frac{\sum{(x_i-\bar{x})^2}}{n-1}} }
$$

Die Formel für die Varianz des Beispiels würde so aussehen:

$$
{\large s^2 = {\frac{48}{4}}=12 }
$$

Überprüfen Sie das mit R:

```{r var, exercise = T, exercise.setup = "ex"}
var(x)
```


### Standardabweichung

Die Standardabweichung $s$ ist die Quadratwurzel der Varianz $s^2$.

$$
{\large s = \sqrt{s^2} = \sqrt{12}=3.46}
$$

Überprüfung mit R:

```{r sd, exercise = T, exercise.setup = "ex"}
sd(x)
```

<br>

::: gelb
Die Standardabweichung ist lediglich eine transformierte Version der Varianz, das zugrundeliegende Messinstrument ist das selbe. Die Empfindlichkeit gegenüber Ausreißern, die der Quadratsumme eingeschrieben ist, wird durch das Ziehen der Wurzel nicht rückgängig gemacht, auch wenn es vielleicht auf den ersten Blick so scheint.
:::

<br>

::: aufgabe
**Coding Challenge**

Setzen Sie die Berechnung der Standardabweichung in R Code um, analog zur mathematischen Formel:

$$
\large s = \sqrt{\frac{\sum_{i = 1}^{n}{(x_i-\bar{x})^2}}{n-1}}
$$

Vergleichen Sie Ihre Ergebnisse mit den Ergebnissen der eingebauten Funktion `sd()`. Nutzen Sie dafür die Gleichheitsbedingung `==`.
:::

::: grau-nb
**Tipps**:

-   Die Quadratwurzel wird mit `sqrt()` (*square root*) gebildet.

-   Quadrieren mit `^2`

-   $n$ kann mit `length()` bestimmt werden

-   Auf die Klammersetzung achten: tendenziell verlangt R mehr Klammern als die normale mathematische Notation
:::

```{r coding, exercise = TRUE, exercise.setup = "ex"}
s <- 
  
s == sd(x)
```

```{r coding-solution}
# verschiedene Stile:

# Kompakt
s <- sqrt(sum((x - mean(x))^2) / (length(x) - 1))

# lesbarer:
qs <- sum((x - mean(x))^2)
df <- length(x) - 1
s <- sqrt(qs / df)

s == sd(x)
```

Super! 

## Quantile

::: infobox
**Einordnung**

Ein Quantil ist eigentlich kein Streuungsmaß, sondern ein Lagemaß, wie Median, Modus oder Mittelwert. 

Der Median ist ein spezielles Quantil, nämlich das 50%-Quantil. 

Erst durch den Abstand von Quantilen erhalten wir ein Streuungsmaß. 
:::
<br>


### Beispieldaten
Wir wechseln zu anderen Beispieldaten, weil sich Quantile schlecht erklären lassen anhand von lediglich 5 Datenpunkten. 

Im WiSe 2022 haben Studierende dieses Kurses sich zusammengeschlossen und Feldforschung an Bioläden in Kassel und Umgebung betrieben. Dabei sind unter anderem die Altersdaten von Kunden gesammelt worden - ein hervorragendes Beispiel.  

Der Datensatz ist in diesem Paket enthalten und kann unter dem Namen `einkaufen` aufgerufen werden. 
Für Erklärungszwecke sind die Altersdaten von genau 100 Personen zufällig aus dem Datensatz gezogen worden. 

### Intuition bekommen

Stellen Sie sich vor, Sie sortieren 100 Personen nach dem Alter und stellen alle in  einer aufsteigenden Reihe auf, vom Baby bis zu Senioren. Dann ist z.B. das 25%-Quantil das Alter, für das gilt:

- wenigstens 25 Personen sind jünger oder gleich alt
- wenigstens 75 Personen sind älter oder gleich alt

#### p-Quantil

```{r quant_ui}
fluidPage(
  sliderInput("p", "p", min = 0, max = 1, value = .25, step = .01, animate = T),
  plotOutput("quantplot"),
  shinyWidgets::radioGroupButtons("method", "Berechnungs-Methode", choices = 1:9,
                                  selected = 1)

)
```

```{r quant_server, context = "server"}
 set.seed(10)
  data <- rtutorials::einkaufen$Alter[is.na(rtutorials::einkaufen$Alter) == F] |>
    sample(size = 100)
  df2 <- data.frame(count = seq_along(data),
                    data,
                    sorted = sort(data, na.last = T))
  pointi <- ggplot(df2, aes(count, sorted)) +
    geom_point() +
    theme_bw() +
    labs(y = "Alter", x = "Position in der Sortierung") +
    scale_y_continuous(breaks = seq(10, 90, by = 10)) +
    scale_x_continuous(breaks = seq(0, 100, by = 25),
                       minor_breaks = seq(10, 100, by = 10))



  output$quantplot <- renderPlot({
    val <- reactiveValues(p = input$p)
    p100 <- val$p * 100
    discrete_quart <- quantile(df2$data, probs = val$p, type = as.numeric(input$method))

    lab <- paste0(p100, "%-Quantil\n = ", round(discrete_quart, digits = 2), " Jahre")

    pointi +
      geom_segment(x = p100, xend = p100, y = 0, yend = discrete_quart,
                   linetype = "dashed", col = "grey") +
      geom_hline(yintercept = discrete_quart, col = "darkblue") +
      annotate(geom = "label",
               y = discrete_quart,
               x = 2, label = lab) +
      coord_flip()
  })

```

<details>
<summary><a>▼ Infos zur Berechnungsmethode</a></summary>

::: blau-nb
Lassen Sie sich nicht davon verunsichern, dass es 9 verschiedene Berechnungsmethoden gibt, die alle zu leicht unterschiedlichen Ergebnissen kommen. Das ist nur der Vollständigkeit halber hier, damit sie nicht denken, Quantile müssten immer auf Datenpunkten liegen wie in Methode 1. 

- Methode 1 ist für diskrete Daten gedacht und liefert nur Quantile, die auch auf tatsächlichen Datenpunkten liegen.

- Methode 8, welche die von R verwendete Standardmethode ist für kontinuierliche Daten, liefert auch Quantile zwischen den Datenpunkten. 

Für mehr Infos siehe `?quantile`.
:::
</details>
<br>

```{r medianquest}
question_numeric("Was ist der Median der obigen Altersdaten?",
                 answer(43, correct = T),
                 allow_retry = T)
```


### Umsetzung in R

#### Die `quantile()`-Funktion

```{r quant_setup}
# learnr exercise Setup
set.seed(10)
alter <- rtutorials::einkaufen$Alter[is.na(rtutorials::einkaufen$Alter) == F] |>
  sample(size = 100)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
# repeat the setup for normal code chunks... :/ because we need it outside exercises too
set.seed(10)
alter <- rtutorials::einkaufen$Alter[is.na(rtutorials::einkaufen$Alter) == F] |>
  sample(size = 100)
```
<br>

::: aufgabe
**1.**

Die Punkte aus den obigen Grafiken sind im Vektor `alter` gespeichert. Verwenden Sie die `quantile()`-Funktion ohne weitere Argumente außer den Daten, um sich die Quartile ausgeben zu lassen.

:::

```{r quantex1, exercise = TRUE, exercise.setup = "quant_setup"}
quantile(alter)

```

::: blau-nb
Ohne weitere Argumente gibt `quantile()` die Quartile aus. Wie gehen wir vor, um spezifische Quantile zu ermitteln?

So sähe ein Beispiel aus, um das 20%-Quantil zu ermitteln:

```r
quantile(x, probs = 0.2)
```
:::
<br>

::: aufgabe
**2.**

Wie alt müsste ein Mensch sein, um gleich alt oder älter als 95% der Stichprobe `alter` zu sein? 

:::

```{r quant95, exercise = TRUE, exercise.setup = "quant_setup"}
quantile(alter, probs = ___)
```


```{r quant_question}
question_checkbox("Welches Skalenniveau muss mindestens vorhanden sein, um Quantile bestimmen zu können?",
                  answer("Nominal", message = "leider falsch, nominale Daten haben keine Reihenfolge"),
                  answer("Ordinal", correct = T, message = "Ab Ordinalskala gibt es Informationen über eine Reihenfolge, und das ist die Mindestvoraussetzung um Quantile berechnen zu können."),
                  answer("Metrisch", message = "Metrische Daten haben nicht nur eine Reihenfolge, sondern auch Abstände, die interpretierbar sind, was für Quantile nicht nötig ist."))
```

### Interquartilsabstand

Der Interquartilsabstand ist die Spanne der Daten, in welcher die mittleren 50% der Werte liegen.

#### Umsetzung in R

```{r iqr, exercise = TRUE, exercise.setup = "quant_setup"}
IQR(alter)
```

```{r iqr_question}
question_checkbox("Welches Skalenniveau muss mindestens vorliegen, um den Interquartilsabstand zu berechnen?",
                  answer("Nominal", message = "Leider falsch, nominale Daten haben keine Abstände"),
                  answer("Ordinal", message = "Ordinale Daten haben leider keine Information über Abstände, weswegen das Bilden der Differenz zwischen Q3 und Q1 „illegal“ ist."),
                  answer("Metrisch", correct = T, message = "Genau! Dadurch dass eine Differenz gebildet wird, interpretieren wir Abstände. Nur metrische Daten enthalten Informationen über Abstände."), 
                  allow_retry = T)
```

::: aufgabe
**Anwendungsaufgabe: Boxplot**

Nehmen Sie sich ein Blatt Papier und einen Stift zur Hand. Zeichnen Sie einen Boxplot der Altersdaten!
Nutzen Sie den Codeblock, um die nötigen Maße zu erhalten. Die Daten sind im Vektor `alter` enthalten. 
:::

::: grau-nb
*Tipp*

In einem Boxplot enthaltene Daten:

- Länge der "Whiskers": 1.5 \* *IQR*, aber maximal bis zum *Minimum / Maximum*
- *1. Quartil*
- *Median*
- *3. Quartil*
:::

```{r boxi, exercise = TRUE, exercise.setup = "quant_setup", exercise.caption = "Boxplot"}
alter
```

```{r boxi-solution}
# Box zeichnen mit Quartilen
quantile(alter)

# Länge der Whiskers
range(alter) # Minumum und Maximum bestimmen

# Theoretische Länge des unteren Whiskers: Q1 - 1.5 * IQR
Q1 <- quantile(alter, probs = .25, names = F)
Q1 - 1.5 * IQR(alter) # kleiner als Minimum 9, außerhalb der Daten

# Theoretische Länge des oberen Whiskers: Q3 + 1.5 * IQR
Q3 <- quantile(alter, probs = .75, names = F)
Q3 + 1.5 * IQR(alter) # größer als Maximum 84, außerhalb der Daten

# -> Whiskers nur bis Min. (9) und Max. (84) zeichnen
```

<br>
<details>
<summary><a>▼ Lösung: Boxplot anzeigen </a></summary>
```{r fig.height=4, fig.width=2}
helpdf <- data.frame(alter)
ggplot(helpdf, aes(y = alter)) +
  geom_boxplot() +
  scale_y_continuous(breaks = seq(10, 90, by = 10)) +
  theme_bw() +
  labs(x = "") +
  scale_x_discrete()
  
```

</details
<br>

### Proof of Concept (wird gelöscht)

Das Diagramm zeigt die Daten dem Alter nach **sortiert**. Auf der x-Achse befindet sich die Position in der Sortierung, die 100. Person hat das größte Alter, und die 1. Person das kleinste.

```{r quantileintro}
data <- alter

df2 <- data.frame(count = seq_along(data), 
                         data, 
                         sorted = sort(data, na.last = T))
       
pointi <- ggplot(df2, aes(count, sorted)) +
         geom_point() +
         theme_bw() +
         labs(y = "Alter", x = "Reihenfolge") +
         scale_y_continuous(breaks = seq(10, 90, by = 10)) +
         scale_x_continuous(breaks = seq(0, 100, by = 25), 
                            minor_breaks = seq(10, 100, by = 10))
pointi
       
       # # might delete later
       # histo <- ggplot(df2, aes(data)) +
       #   geom_histogram(binwidth = 5, boundary = 5, col = "white", fill = "steelblue", alpha = .7) +
       #   scale_x_continuous(breaks = seq(5, 90, by = 5)) +
       #   theme_bw() +
       #   labs(x = "Alter", y = "Anzahl Personen")

```

```{r}
message("Bild einfügen mit Personen in Reihe dem Alter nach sortiert")
```

Dann können wir das 25% - Qua**nnnnnn**til bestimmen, was dem 1. Qua**rrrrr**til (wie *quarter* = Viertel) entspricht. 

Das 25% - Quantil ist der Wert, unterhalb de 25% der Werte liegen. 

```{r quartile1}
probs <- .25
probs100 <- probs * 100
discrete_quart <- quantile(df2$data, probs = probs, type = 1) # Diskrete Quantile berechnen für die Grafik (visuelle Trickserei, aber lässt unschöne Fragen zurück)


pointi +
  geom_hline(yintercept = discrete_quart, col = "darkblue") +
  geom_segment(x = probs100, xend = probs100, y = 0, yend = discrete_quart) +
         annotate(geom = "label", 
                  y = discrete_quart, 
                  x = 1, label = "Q1")
```

Das wiederholen wir jetzt noch für das zweite und dritte Quartil!

```{r}
probs <- c(0.25, 0.5, 0.75)
probs100 <- probs * 100
discrete_quart <- quantile(df2$data, probs = probs, type = 1)
helper_df <- data.frame(probs, probs100, discrete_quart)

pointi + 
    geom_hline(yintercept = discrete_quart, col = "darkblue") +
    geom_segment(data = helper_df, 
                 x = probs100, 
                 xend = probs100, 
                 y = 0, 
                 yend = discrete_quart, 
                 linetype = "dashed", 
                 alpha = .4) +
    annotate(geom = "label", 
             y = discrete_quart, 
             x = 1, label = c("Q1", "Q2", "Q3"))

```

Jetzt sind die Daten in 25%-Abschnitte aufgeteilt. Hier wird jetzt auch sichtbar, warum das sinnvoll ist um Streuung zu beschreiben:

Es ist klar zu sehen, dass die mittleren 50 % auf dichterer Fläche konzentriert sind als die 25% darüber und darunter. 

Wenn wir jetzt einen Boxplot darüberlegen, wird intuitiv klar, wie er funktioniert:

```{r}
pointi + 
  geom_boxplot(alpha = 0.8, x = 50, xmin = 0, xmax = 100, fill = "pink") +
  annotate(geom = "label", 
            y = quantile(df2$data, probs = c(0.25, 0.5, 0.75)), 
            x = 1, label = c("Q1", "Q2", "Q3"))
       

```

### Umsetzung in R

Jetzt kommen die technischen Details, die vormals ausgelassen wurden :)

Es wurde nur erwähnt, dass ein $p$-Quantil der Wert ist, unter dem $p$ der Werte liegen. Aber wie genau wird dieser Wert bestimmt?

Tja, die `quantile()`-Funktion kann Quantile durch ganze **8** verschiedene Methoden berechnen. Aber keine Sorge, in dieses Rabbithole gehen wir nicht hinein. Wir geben uns damit zufrieden, wenn uns ein Quantil ausgegeben wird, wie es zustande kommt, vernachlässigen wir. 


## Überblick deskriptivstatistische Kennwerte

Die Berechnung vieler statistischer Kennwerte ist in R ziemlich straight forward: Es gibt dafür oft eingebaute Funktionen, und wenn nicht, gibt es Pakete, die Funktionen enthalten. Immerhin wurde R entworfen mit dem Ziel, statistische Berechnungen zu ermöglichen.

Sie kennen nun bereits einige statistische Kennwerte. Es gibt noch viele mehr, und es geht nicht darum, sich alles zu merken, sondern zu wissen, wo Sie die passende Funktion für das gewünschte Maß finden. Oft reicht dafür eine kurze Suche im Internet.\
\
Alle diese Funktionen sind sich ähnlich: Sie nehmen als erstes Argument einen Vektor, der die Werte enthält, mit denen gerechnet werden soll. Deswegen haben Sie im ersten Teil gelernt, wie Sie Vektoren erstellen und speichern.

Hier nochmal eine Übersicht über deskriptivstatistische Kennwerte mit ihren eingebauten Funktionen:

+-----------------------+---------------------------+----------------+
| Name                  | Code                      | Skalenniveau   |
+=======================+===========================+================+
| arithmetisches Mittel | `mean()`                  | Intervall      |
+-----------------------+---------------------------+----------------+
| Median                | `median()`                | Ordinal        |
+-----------------------+---------------------------+----------------+
| Modus                 | `table()`\                | Nominal        |
|                       | oder mit externem Paket:\ |                |
|                       | `modeest::mfv()`          |                |
+-----------------------+---------------------------+----------------+
| Minimum und Maximum   | `range()`                 | Ordinal        |
+-----------------------+---------------------------+----------------+
| Spannweite            | `diff(range())`           | Intervall      |
+-----------------------+---------------------------+----------------+
| Quantile              | `quantile()`              | Ordinal        |
+-----------------------+---------------------------+----------------+
| Interquartilsabstand  | `IQR()`                   | Intervall      |
+-----------------------+---------------------------+----------------+
| Varianz               | `var()`                   | Intervall      |
+-----------------------+---------------------------+----------------+
| Standardabweichung    | `sd()`                    | Intervall      |
+-----------------------+---------------------------+----------------+

: Übersicht: Maße der zentralen Tendenz und Maße der Streuung in R

Hilfreich ist auch der Befehl `summary()`, der automatisch eine Zusammenfassung der wichtigen deskriptivstatistischen Kennwerte erstellt.

```{r test, exercise=TRUE, exercise.caption="Zum Ausprobieren"}

```

## Learnings

### neue Konzepte

-   nötige Skalenniveaus für Modus, Median und Mittelwert

-   Sinn von Abweichungen vom Mittelwert und Quadratsummen

-   Die Formel für die Varianz

### neue Funktionen

| Code               | Beschreibung                    |
|--------------------|---------------------------------|
| `range()`          | Minimum und Maximum             |
| `diff(range())`    | Spannweite                      |
| `var()`            | variance                        |
| `sd()`             | standard deviation              |
| `quantile()`       | Quantile berechnen              |


