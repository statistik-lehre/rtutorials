---
title: "Stichprobenkennwerteverteilung"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
    allow_skip: true
    progressive: true
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Demonstration des Konzepts mit realer und simulierter Stichprobenziehung
resource_files:
- css/boxes.css
tutorial:
  id: sampling
  version: 1
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(moderndive)
library(shiny)
```

## Lernziele

W√§hrend wir bisher vor allem deskriptive Statistiken ausgewertet haben, also unsere Daten beschrieben haben, erkunden wir heute die Grundlagen der Inferenzstatistik.
Dies ist ein Bereich der Statistik, der es uns erm√∂glicht, von einer Stichprobe auf die gesamte Population zu schlie√üen.
Wir konzentrieren uns also nun darauf zu verstehen, wie wir aus unseren Stichproben Schlussfolgerungen f√ºr die gesamte Population ziehen k√∂nnen.

Dabei werden viele neue Konzepte und Begriffe fallen.
Einige davon sind:

<input type="checkbox" unchecked> Stichprobenvariation (*sampling variation*)</input>

<input type="checkbox" unchecked> Stichprobenkennwerteverteilung (*samling distribution*) </input>

<!-- <input type="checkbox" unchecked> zentraler Grenzwertsatz (*central limit theorem*)</input> -->

<!-- <input type="checkbox" unchecked> Punktsch√§tzungen </input> -->

<!-- <input type="checkbox" unchecked> Intervallsch√§tzungen </input> -->

<!-- <input type="checkbox" unchecked> $t$-Verteilung </input> -->

<!-- <input type="checkbox" unchecked> $t$-Test </input> -->

## Stichprobenkennwerteverteilung

Der fundamentale Baustein f√ºr das Verst√§ndnis von Inferenzstatistik ist zu verstehen, was eine\
**Stichproben---Kennwerte---Verteilung** ist.

Dazu gibt es ein tolles Buchkapitel im frei verf√ºgbaren Online-Lehrbuch [*Modern Dive*](https://moderndive.com/7-sampling.html), was wir hier √ºbernehmen [@ismay2022].
Der folgende Teil ist eine √úbersetzung von Teilen des Kapitels 7, leicht adaptiert.

<hr>

In diesem Gef√§√ü ist eine unbekannte Zahl roter und wei√üer gleichgro√üer Kugeln.
Es wurde gut durchmischt.
Wir fragen uns jetzt: ‚ÄûWelcher Anteil der Kugeln ist rot?"

![Ein Gef√§√ü mit roten und wei√üen Kugeln](images/bowl.jpg){width="100%"} 
[Source: [@ismay2022]]

Eine M√∂glichkeit, den Anteil roter Kugeln zu bestimmen, w√§re eine vollst√§ndige Z√§hlung aller Kugeln.
Dann k√∂nnte die Zahl der roten Kugeln durch die Gesamtanzahl geteilt werden.
In der Sch√ºssel sind aber mit Absicht so viele Kugeln, dass das ein langer und erm√ºdender Prozess w√§re.

### Eine Stichprobe ziehen

Anstelle der vollst√§ndigen Z√§hlung k√∂nnen wir eine Schaufel mit kugelf√∂rmigen Aussparungen verwenden, um 50 zuf√§llige B√§lle aus dem Gef√§√ü zu ziehen.

![Eine Schaufel nutzen](images/shovel1.jpg){width="100%"}
[Source: [@ismay2022]]

![50 Kugeln wurden zuf√§llig gezogen](images/shovel1_close.jpg){width="100%"}
[Source: [@ismay2022]]

17 Kugeln von 50 sind rot - damit betr√§gt der Anteil $$\frac{17}{50}=0.34=34 \%$$

Wir k√∂nnen den Anteil der roten B√§lle in dieser Schaufel als eine Sch√§tzung f√ºr die gesamte Sch√ºssel verwenden.
W√§hrend es zwar nicht so exakt ist wie alle Kugeln aus der gesamten Sch√ºssel zu z√§hlen, hat unsere Sch√§tzung von 34% sehr viel weniger Zeit und Energie gekostet.

Nun denn, lasst uns sagen, wir w√ºrden diesen Prozess jetzt noch einmal von vorne wiederholen.
In anderen Worten, wir tun die 50 Kugeln zur√ºck in die Sch√ºssel und beginnen von vorn.
W√ºrden wir wieder genau 17 rote Kugeln ziehen?
In anderen Worten, w√§re unser Sch√§tzer f√ºr den Anteil roter Kugeln im Gef√§√ü wieder 34%?
Vielleicht?

Was, wenn wir die diese Aktivit√§t mehrmals wiederholen w√ºrden?
W√ºrden wir jedes Mal 17 rote Kugeln erhalten, aka einen Anteil von 34% f√ºr die gesamte Sch√ºssel sch√§tzen?
Sicherlich nicht.
Lasst uns diese √úbung nun mehrmals wiederholen mit der Hilfe von 33 Gruppen von Freunden, um zu verstehen wie die Werte sich durch Wiederholung ver√§ndern.

### 33 mal eine Stichprobe ziehen

Jede der 33 Gruppen wird das Folgende tun:

-   die Schaufel nutzen, um 50 Kugeln zu ziehen
-   Anzahl der roten Kugeln z√§hlen und den Anteil ausrechnen
-   Die Kugeln zur√ºcklegen in die Sch√ºssel
-   Den Inhalt etwas mischen, um nicht die Resultate der n√§chsten Gruppe zu beeinflussen

![Stichprobenziehung 33 mal wiederholen](images/33shovels.png){width="100%"}
[Source: [@ismay2022]]

Jede der 33 Gruppen tr√§gt dann den von ihnen bestimmten Anteil roter Kugeln in ihrer Stichprobe in einem handgezeichneten Histogramm ein:

![Ein Histogramm der verschiedenen Anteile bauen](images/hist1.jpg){width="100%"}
[Source: [@ismay2022]]

![Die ersten 10 handgemalten Eintr√§ge](images/hist2.jpg){width="100%"}
[Source: [@ismay2022]]

Schau dir das Histogramm mit den ersten 10 handgezeichneten Eintr√§gen an:

-   Am unteren Ende hat eine Gruppe in ihren 50 Kugeln einen Anteil zwischen 20-25% roten gefunden

-   Am oberen Ende wurde in einer Stichprobe mit 50 Kugeln ein Anteil von 45-50% roten Kugeln gefunden.

-   Allerdings war der am h√§ufigsten auftretende Anteil zwischen 30-35%, ganz in der Mitte der Verteilung.

-   Die Form der Verteilung kann man als grob "glockenf√∂rmig" beschreiben (mit etwas gutem Willen)

Lasst uns jetzt ebendieses Histogramm noch einmal in *R* herstellen mit den Daten-Visualisierungsskills die du im letzten Tutorial erlangt hast!
Die 33 Gruppen sind im `tactile_prop_red`-Dataframe gespeichert, der im `moderndive`-Paket mitgeliefert wird.

F√ºhre den Codeblock aus, um dir die ersten 10 von 33 Zeilen anzeigen zu lassen:

```{r tibble, exercise = TRUE}
moderndive::tactile_prop_red
```

Das hier ist zu sehen: F√ºr jede Gruppe haben wir die Namen der Studierenden (`group`), die Anzahl roter Kugeln(`red_balls`), und den zugeh√∂rigen Anteil aus 50 Kugeln (`prop_red`).
Au√üerdem haben wir die Variable `replicate`, welche die Zeilen nummeriert.
Wir haben diesen Namen ausgesucht, weil jede Zeile als eine Instanz einer replizierten (wiederholten) Aktivit√§t besteht.

::: aufgabe
Lasst uns die Verteilung der 33 Proportionen roter Kugeln visualisieren mithilfe von `ggplot` und `geom_histogram` mit `binwidth = 0.05` und einer Umrandung in `"white"`!

F√ºr deinen Komfort ist das Paket `ggplot2` bereits in diesem Tutorial.
:::

```{r hist, exercise=TRUE}
# f√ºge ein histogram mit binwidth = 0.05 hinzu
ggplot(moderndive::tactile_prop_red, aes(x = prop_red)) +
  labs(x = "Anteil roter Kugeln", 
  title = "Verteilung von 33 Stichproben mit 50 Kugeln") +
```

```{r hist-solution}
ggplot(moderndive::tactile_prop_red, aes(x = prop_red)) +
  geom_histogram(binwidth = 0.05, boundary = 0.4, color = "white", fill = "darkred") +
  labs(x = "Anteil roter Kugeln", title = "Verteilung von 33 Stichproben mit 50 Kugeln")

```

Tipp: mit dem Argument `boundary = 0.4` kannst du f√ºr ein Histogramm den Trennwert f√ºr die Kategorien bestimmen (bei Wert *0.4* werden die Kategorien getrennt, siehe Plot). Doch beachte dabei, dass dies auch die Kategorien entsprechend ver√§ndert/verschiebt.

### Was haben wir gerade gemacht?

Du hast gerade eine Stichproben-Kennwerte-Verteilung hergestellt!
Das ist nichts anderes als die **Verteilung** eines **Kennwerts** √ºber viele **Stichproben** hinweg.

In diesem Fall ist der Kennwert der Anteil roter Kugeln.
F√ºr jede Zufalls-Stichprobe wurde dieser Kennwert berechnet.
Im Histogramm wurde dann die Verteilung des Kennwerts visualisiert.
Dort sehen wir, wie der Anteil roter Kugeln √ºber verschiedene Stichproben hinweg schwankt.
Diese Schwankung ist als **Stichprobenvariation** bekannt.

Es mag simpel erscheinen, aber die Idee, dass zuf√§llig gezogene Stichproben einer zuf√§lligen Schwankung unterliegen ist fundamental! Merken.üí°

Damit hast du die ersten zwei Schl√ºsselbegriffe gelernt!

1.  **Stichprobenvariation** (*sampling variation*)
2.  **Stichprobenkennwerteverteilung** (*sampling distribution*)

Im n√§chsten Abschnitt werden wir die soeben durchgef√ºhrte praktische Probennahme mit einem Computer simulieren!
Dadurch k√∂nnen wir nicht nur das Stichprobenziehen viel √∂fter als 33 Mal wiederholen, sondern auch Schaufeln mit einer anderen Anzahl von L√∂chern als nur 50 verwenden.

```{r learning_check1}
quiz(
  caption = "Learning Check",
  
  learnr::question_text(
    text = "Warum war es wichtig, die Kugeln zu mischen, bevor die Stichprobe gezogen wurde?", 
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Damit sichergestellt war, dass die Stichprobe zuf√§llig ist."
    ), 
  question_text(
    text = "Warum haben nicht alle 33 Gruppen die selbe Proportion an roten Kugeln gezogen?",
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Wegen Stichprobenvariation! Da die Stichproben zuf√§llig sind, gibt es zuf√§llige Abweichungen."
  )
)
```

## Virtuelles Stichprobenziehen

Im vorherigen Abschnitt haben wir taktile Stichprobenziehungen mit der Hand gemacht aus einer echten Sch√ºssel mit richtigen Kugeln und realen Schaufeln.Dadurch konnten wir ein solides Verst√§ndnis aufbauen von den Grundideen hinter dem Stichprobenziehen.
In diesem Abschnitt werden wir das taktile Stichprobenziehen simulieren durch ein virtuelles Stichprobenziehen mit dem Computer.

### einmalige Nutzung der Schaufel

Lasst uns damit beginnen, eine einzelne Stichprobe zu ziehen.
Daf√ºr brauchen wir zuerst ein virtuelles Analog zur Sch√ºssel mit den Kugeln.
Zu diesem Zweck gibt es den Dataframe `bowl` im `moderndive`-Paket.
Eine Zeile in diesem Datensatz entspricht einer tats√§chlichen Kugel in der Sch√ºssel:

```{r bowl, exercise = TRUE}
library(moderndive)
bowl

nrow(bowl)
```

`bowl` hat 2400 Zeilen, was hei√üt, dass die Sch√ºssel 2400 gleichgro√üe B√§lle enth√§lt.
Die erste Variable `ball_ID` wird als ‚ÄûIdentifikationsvariable‚Äú verwendet, um die einzelnen Kugeln zu unterscheiden, auch wenn die Kugeln nat√ºrlich keine Nummern tragen.
Die zweite Variable `color` zeigt ob eine bestimmte Kugel rot oder wei√ü ist.

::: aufgabe
√úberzeuge dich nochmal, dass es wirklich sehr viele Kugeln sind!
:::

```{r manyballs, exercise = TRUE}
print(bowl, n = 2000)
```

### virtuelle Schaufel

Jetzt brauchen wir noch ein virtuelles Analog zu unserer Schaufel, um virtuelle Stichproben von jeweils $n = 50$ Kugeln zu ziehen.
Wir werden daf√ºr die `rep_sample_n()`-Funktion aus dem `moderndive`-Paket benutzen.
Diese Funktion erlaubt uns, `rep`eated `sample`s der Gr√∂√üe `n` zu nehmen.

```{r virtualshovel, exercise = TRUE}
virtual_shovel <- bowl |>
  rep_sample_n(size = 50, reps = 1)
virtual_shovel
```

Was sehen wir?

Der Output `virtual_shovel` hat 50 Zeilen, f√ºr jede der gew√ºnschten 50 Kugeln eine Zeile.

Die `ball_ID`-Variable zeigt, welche der 2400 Kugeln gezogen wurden und die `color`-Variable verr√§t uns ihre Farbe.

Aber was sagt die `replicate`-Variable uns?
In diesem Fall ist `replicate` = 1 f√ºr alle 50 Eintr√§ge.
Das sagt uns, dass diese 50 Zeilen zur ersten Stichprobe geh√∂ren.
Wir werden gleich sehen, was passiert wenn wir virtuell 33 Stichproben ziehen - dann nimmt `replicate` Werte zwischen 1 und 33 an.

### Proportion berechnen

Unser Ziel ist nun mithilfe von `dplyr`-Verben wie `mutate()` und `summarize()` den Anteil roter Kugeln in der Stichprobe zu berechnen. Die Funktionen kennst du aus dem *Data Wrangling* Tutorial

::: aufgabe
Nutze dein wissen zu `mutate()`, um eine neue Variable `is_red` zu erstellen, die f√ºr Kugeln, deren Farbe (`color`) rot ist, den Wert `TRUE` ausgibt und f√ºr alle anderen `FALSE`.

Da du bisher keine boolschen Variablen erstellt hast: das kannst du mittels der Operatoren (`==`, `!=`, ect.) bewerkstelligen, ist die Bedingung erf√ºllt bekommst du ein TRUE andererseits ein FALSE. Beispiel: `boolean <- (df, variable != 2) ` ist ein Vektor mit Eintr√§gen `TRUE` immer wenn die Variable **nicht 2** ist und `FALSE` wenn sie es ist. Mehr Infos zu boolschen Variablen findest du [hier.](https://www.r-bloggers.com/2021/09/r-booleans-comparison-and-logical-operators/)
:::

```{r wrangle, exercise = TRUE, exercise.cap = "Neue Spalte erstellen", exercise.setup = "virtualshovel"}
virtual_shovel |> 
  mutate() 
```

```{r wrangle-hint}
# f√ºge die Bedingung `farbe ist rot` hinzu
virtual_shovel |> 
  mutate(is_red = (Bedingung)) 
```

```{r wrangle-solution}
virtual_shovel |> 
  mutate(is_red = (color == "red")) 
```

<details>

<summary><a>‚ñº \* Erkl√§rung:</a></summary>

Der erste Schritt ist, eine neue Variable erstellen, die anzeigt ob eine Kugel rot ist und daf√ºr entweder `TRUE` oder `FALSE` enth√§lt.
Daf√ºr nutzen wir den Vergleichsoperator `==`, welcher jedes Element der Spalte `color` abfragt, ob es dem Wert "red" entspricht, und f√ºr jedes Element (jede Kugel) `TRUE` oder `FALSE` ausgibt.
Dieser neue logische Vektor wird in der Spalte `is_red` abgespeichert.

</details>

Wir sehen, dass √ºberall dort, wo `color == "red"`, der logische Wert `TRUE` zur√ºckgegeben wurde, und √ºberall wo das nicht gilt, `FALSE` steht.

::: aufgabe
Jetzt ben√∂tigen wir noch die Anzahl der roten Kugeln. Daf√ºr kannst du in `summarize()` die Funktion `sum()` zur Ermittlung der Summe von der Variable `is_red` nutzen. 

Das klappt, da f√ºr *R* `TRUE = 1` und `False = 0` ist.
:::

```{r sum, exercise = TRUE, exercise.cap = "Summarize", exercise.setup = "virtualshovel"}
# f√ºge die Argumente in die Funktion summarize() ein
virtual_shovel |>
  mutate(is_red = (color == "red")) |>
  summarize()
```

```{r sum-hint}
# f√ºge die Variable in sum() hinzu
virtual_shovel |>
  mutate(is_red = (color == "red")) |>
  summarize(num_red = sum())
```

```{r sum-solution}
virtual_shovel |>
  mutate(is_red = (color == "red")) |>
  summarize(num_red = sum(is_red))
```

<details>

<summary><a>‚ñº \* Erkl√§rung 2:</a></summary>

Im zweiten Schritt berechnen wir den Anteil roter Kugeln mit der `summarize()`-Funktion.
Erinnere dich, dass `summarize()` einen Data Frame mit vielen Zeilen als Input nimmt und als Output einen Data Frame mit einer einzigen Zeile zur√ºckgibt, die *summary statistics* wie `mean()` oder `median()` enth√§lt. In diesem Fall nutzen wir die Summe `sum()`.

*Warum funktioniert das?*

Weil *R* `TRUE` wie die Zahl `1` behandelt und `FALSE` wie eine `0`.
Also ist das Aufsummieren von `TRUE` und `FALSE` genau wie das Summieren von `1` und `0`.
Letztendlich z√§hlt diese Operation die Anzahl aller roten Kugeln.

</details>

Die Zahl der roten Kugeln schwankt, wenn du den Code neu ausf√ºhrst - Warum?
Wegen der Stichprobenvariation (*sampling variation*)!

::: aufgabe
Drittens und als letzten Punkt berechnen (`mutate()`) wir den Anteil roter Kugeln (`prop_red`), in dem wir die Anzahl `num_red` durch die Stichprobengr√∂√üe (in diesem Fall 50) dividieren (`/`). 
:::

```{r div, exercise = TRUE, exercise.cap = "Durch n dividieren", exercise.setup = "virtualshovel"}
# f√ºge ein weiteres mutate() zur Berechnung von prop_red hinzu
virtual_shovel  |>  
  mutate(is_red = color == "red") |>  
  summarize(num_red = sum(is_red)) |>  

```

```{r div-hint}
# f√ºge die Berechnung von prop_red hinzu
virtual_shovel  |>  
  mutate(is_red = color == "red") |>  
  summarize(num_red = sum(is_red)) |>  
  mutate(prop_red = )
```

```{r div-solution}
virtual_shovel  |>  
  mutate(is_red = color == "red") |>  
  summarize(num_red = sum(is_red)) |>  
  mutate(prop_red = num_red / 50)
```

Die Proportion l√§sst sich auch als Prozentzahl interpretieren.
Zum Beispiel k√∂nntest du bei 0.24 sagen, ‚Äû*24% der Kugeln waren rot*‚Äú.

Jetzt machen wir den Code noch etwas kompakter, indem wir den ersten `mutate()`- und den zweiten `summarize()`-Aufruf kombinieren:

```{r comb, exercise = TRUE, exercise.cap = "kompakter Code", exercise.setup = "virtualshovel"}
virtual_shovel |>  
  summarize(num_red = sum(color == "red")) |>  
  mutate(prop_red = num_red / 50)
```

Sehr gut!

Wenn wir die Stichprobenziehung nun √∂fter wiederholen, wird es wahrscheinlich zu Stichprobenvariation kommen, und es wird nicht immer der selbe Anteil roter Kugeln herauskommen.
Wiederholen wir die Stichprobenziehung nun 33 Mal, wie im letzten Kapitel, dieses Mal aber mit der virtuellen Schaufel!

### Nutze die virtuelle Schaufel 33 mal

Erinnere dich, dass im letzten Kapitel 33 Gruppen von Studierenden jeweils die Schaufel genutzt haben, um eine Stichprobe zu ziehen, was zu 33 Stichproben mit jeweils $n = 50$ Kugeln gef√ºhrt hat.
Dann haben wir daraus 33 Proportionen berechnet.

In anderen Worten, wir haben das Stichprobenziehen 33 mal repliziert (wiederholt).
Wir k√∂nnen das virtuell wiederholen, wieder mit der `rep_sample_n()`-Funktion.
Dieses Mal f√ºgen wir das Argument `reps = 33` hinzu, was R sagt, dass wir das Stichprobenziehen 33 mal wiederholen wollen.

Die Ergebnisse speichern wir in einem Data Frame namens `virtual_samples`.
W√§hrend wir im folgenden Output lediglich die ersten 10 Zeilen angezeigt bekommen, passiert das wirklich Wichtige erst in Zeile 51.

Lass uns deshalb `print(n = ...)`nutzen, um die ersten 60 Zeilen anzeigen zu lassen!
```{r rep33, exercise = TRUE, exercise.cap = "33 Stichproben ziehen"}
virtual_samples <- bowl |>
  rep_sample_n(size = 50, reps = 33)

virtual_samples|> print(n = 60)
```

Du siehst, dass die ersten 50 Zeilen der Spalte `replicate` den Wert 1 tragen, und die n√§chsten 50 Zeilen den Wert 2, und so weiter, bis zur 33.
Das sagt uns dass die ersten 50 Zeilen zur ersten Stichprobe geh√∂ren, die n√§chsten 50 Zeilen zur zweiten, und so weiter.
Da sich dieses Muster durchg√§ngig wiederholt, hat `virtual_samples` $33 \cdot 50 = 1650$ Zeilen.

#### Proportionen berechnen

Nun wollen wir den jeweiligen Anteil roter Kugeln in den 33 Stichproben herausfinden.
Wir werden die selben `dplyr`-Verben wie zuvor verwenden, aber dieses Mal noch mit `group_by()` nach der `replicate`-Variable gruppieren.

Erinnere dich daran, dass bei `group_by()` vor `summarize()` die *summary statistics* f√ºr jede Gruppe einzeln berechnet werden, unsere Ausgabe also 33 Zeilen haben wird.

::: aufgabe
Nutze `group_by()`, um die Daten nach replicate zu gruppieren und dann in die `summarize()` Funktion zu pipen.
:::

```{r prop33, exercise = TRUE, exercise.cap = "33 Proportionen berechnen", exercise.setup = "rep33"}
virtual_prop_red <- virtual_samples |> 
  summarize(red = sum(color == "red")) |>
  mutate(prop_red = red / 50)

virtual_prop_red
```

```{r prop33-solution}
virtual_prop_red <- virtual_samples |> 
  group_by(replicate) |>
  summarize(red = sum(color == "red")) |>
  mutate(prop_red = red / 50)

virtual_prop_red
```

Du siehst die ersten 10 Zeilen von 33, was v√∂llig ausreichend ist um zu begreifen, dass wir nun den Anteil roter Kugeln f√ºr jede der 33 Stichproben errechnet haben.

Wie bei der realen Stichprobenziehung gibt es auch hier Stichprobenvariation zwischen den Anteilen roter Kugeln in den einzelnen Stichproben.

#### Visualisierung

Nun wollen wir die Stichprobenkennwerteverteilung der 33 Stichproben visualisieren.
Beachte, dass wir die Argumente `binwidth = 0.05` und `boundary = 0.4` hinzugef√ºgt haben.
Erinnere dich daran, den `boundary = 0.4` zu setzen, um sicherzustellen, dass die Grenze einer Kategorie bei 0.4 liegt.
Weil `binwidth = 0.05` ebenfalls festgelegt ist, wird das Kategorien mit Grenzen bei 0.30, 0.35, 0.40, 0.45 und so weiter erzeugen.

```{r plot33, exercise = TRUE, exercise.cap = "Histogramm", exercise.setup = "prop33"}
ggplot(virtual_prop_red, aes(x = prop_red)) +
  geom_histogram(binwidth = 0.05, boundary = 0.4, color = "white") +
  labs(x = "Anteil roter Kugeln aus 50", 
       subtitle = "simulierte Stichprobenziehung (33 mal)", 
       title = "Verteilung der Anteile") 
```

Wir sehen, dass wir seltener Anteile unter 25% oder √ºber 45% erhalten haben.
Die am h√§ufigsten auftretenden Anteile liegen zwischen 25% und 45%.
*Warum gibt es diese Unterschiede in den Anteilen?*
Wegen der **Stichprobenvariation**.

Vergleichen wir das Histogramm aus der realen Stichprobenziehung mit dem aus der virtuellen:

```{r compare}
ggplot(moderndive::tactile_prop_red, aes(x = prop_red)) +
  geom_histogram(
    binwidth = 0.05, 
    boundary = 0.4, 
    color = "white", 
    fill = "darkred") +
  labs(x = "Anteil roter Kugeln", 
       subtitle = "reale Stichprobenziehung (33 mal)", 
       title = "Verteilung der Anteile")
```

Du siehst, dass beide Histogramme gewisse √Ñhnlichkeiten aufweisen, was das Zentrum und die Variation angeht, obwohl sie nicht identisch sind.
Auch das ist wieder einmal auf die Stichprobenvariation zur√ºckzuf√ºhren.
Und mit gutem Willen k√∂nnen wir sagen, dass beide Verteilungen eine gewisse Glockenform annehmen.

```{r learningcheck2}
quiz(
  caption = "Learning Check",
  
  learnr::question_text(
    text = "Warum konnten wir den Effekt der Stichprobenvariation erst sehen, als wir mehrere (z.B. 33) Stichproben gezogen haben und nicht bei einer Stichprobe?", 
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Weil wir aus einer Stichprobe nur einen Anteil berechnen konnten, und den nicht vergleichen konnten mit einem anderen. Um eine Bandbreite von Anteilen zu erreichen, brauchten wir mehrere Stichproben."
    )
)
```

### Nutze die Schaufel 1000 mal

Jetzt wollen wir die Effekte von Stichprobenvariation nicht nur f√ºr 33 Stichproben untersuchen, sondern eher f√ºr gr√∂√üere Anzahlen, sagen wir mal 1000.
Wir haben zwei M√∂glichkeiten an diesem Punkt: Wir k√∂nnten die Studierenden per Hand 1000 Stichproben mit je 50 Kugeln ziehen lassen und h√§ndisch die 1000 Proportionen ausrechnen lassen.
Das w√§re aber ein m√ºhseliger und zeitaufwendiger Prozess.
Genau darin sind Computer besonders exzellent: lange und monotone Aufgaben automatisch und schnell ausf√ºhren.
An dieser Stelle werden wir also h√§ndisches Stichprobenziehen hintenanstellen und lieber eine Simulation verwenden.

Wir werden noch einmal die `rep_sample_n()`-Funktion verwenden, wieder mit der Stichprobengr√∂√üe bei `size = 50`, aber dieses Mal die Anzahl der Wiederholungen `reps = 1000` setzen.
Auch hier schauen wir uns ein paar mehr Zeilen an mit `print(n = ...)`.

```{r reps1000, exercise = TRUE, exercise.cap = "1000 Stichproben ziehen"}
virtual_samples <- bowl |>
  rep_sample_n(size = 50, reps = 1000)
virtual_samples |> print(n = 300)
```

`virtual_samples` hat jetzt ganze $1000 \cdot 50 = 50 000$ Zeilen! 
Mit dem selben *Data Wrangling* wie zuvor berechnen wir jetzt f√ºr die 1000 Stichprobe jeweils den Anteil roter Kugeln.

```{r prop1000, exercise = TRUE, exercise.setup = "reps1000", exercise.cap = "1000 Anteile berechnen"}
virtual_prop_red <- virtual_samples |>
  group_by(replicate) |>
  summarize(red = sum(color == "red")) |> 
  mutate(prop_red = red / 50)

virtual_prop_red

```

Wir sehen, dass es nun 1000 Zeilen gibt mit je einer Proportion roter Kugeln f√ºr eine Stichprobe.
Nun nutzen wir den selben Code wie zuvor, um die Verteilung der Proportionen als Histogramm zu visualisieren.

```{r plot1000, exercise = TRUE, exercise.cap = "Histogramm", exercise.setup = "prop1000"}
ggplot(virtual_prop_red, aes(x = prop_red)) +
  geom_histogram(binwidth = 0.05, boundary = 0.4, color = "white") +
  labs(x = "Anteil roter Kugeln aus 50", 
       subtitle = "simulierte Stichprobenziehung (1000 mal)", 
       title = "Verteilung der Anteile") 
```

Hier ist nun eindeutig die Kategorie 35% - 40% die am h√§ufigsten auftretende Proportion roter Kugeln.

Ganz selten finden wir nun auch Anteile unter 20% oder √ºber 55%.
Diese sind jedoch wirklich selten.
Vor allem haben wir jetzt eine Verteilung, die auch ohne guten Willen "glockenf√∂rmig" genannt werden d√ºrfte.
Sie ist tats√§chlich nah an einer *Normalverteilung* dran.

```{r learningcheck3}
quiz(
  caption = "Learning Check",
  
  learnr::question_text(
    text = "Wenn du das Histogramm ansiehst, w√ºrden du sagen, es ist wahrscheinlich, eine einzelne Stichprobe mit 30% - 35% roten Kugeln zu ziehen?", 
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Das kommt relativ h√§ufig vor, in ca. 180 von 1000 F√§llen (die genaue Zahl kommt nat√ºrlich auf Ihre konkreten 1000 Stichproben an)."
    ),
  learnr::question_text(
    text = "Und was ist mit einer Stichprobe mit unter 10% roten Kugeln?", 
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Die Chance ist verschwindend gering, so dass es in den meisten F√§llen bei 1000 Stichproben nicht einmal vorkommt."
    )
)
```

## verschieden gro√üe Schaufeln verwenden

Nehmen wir an, du h√§ttst die Wahl zwischen drei verschiedenen Schaufeln, um Stichproben zu ziehen: Mit **25**, **50** oder **100** Slots.

![Drei Schaufeln f√ºr drei verschiedene Stichprobengr√∂√üen](images/three_shovels.png){width="100%"}

[Source: [@ismay2022]]

Wenn dein Ziel immer noch ist, die Proportion der roten Kugeln in der gesamten Sch√ºssel m√∂glichst gut abzusch√§tzen, welche der Schaufeln w√ºrdest du verwenden?

Die meisten Menschen w√ºrden die Schaufel mit 100 Slots w√§hlen, denn es w√ºrde den "besten" Sch√§tzer f√ºr die wahre Proportion liefern.
Aber wann ist ein Sch√§tzer der "beste"?
Das gehen wir in diesem Kapitel an.

Wir k√∂nnen unsere neu erlernten Werkzeuge f√ºr simulierte Stichprobenziehung nehmen, um den Effekt verschiedener Stichprobengr√∂√üen zu untersuchen!
In anderen Worten, wir nutzen `rep_sample_n()` mit `size =` gesetzt auf `25`, `50` und `100`, w√§hrend wir die Anzahl der Wiederholungen auf `reps = 1000` festhalten. Immer wieder werden also die folgenden Schritte simuliert:

1.  Schaufel nutzen
2.  Proportionen berechnen
3.  Histogramm erstellen.

Diese Schritte haben wir im Hintergrund automatisiert und ein Interface geschrieben, wo du die Inputs hineingeben und das Histogramm hinaus bekommst.

::: aufgabe
Experimentiere mit der **Stichprobengr√∂√üe** (50, 100, 200), w√§hrend die Zahl von Stichprobenziehungen konstant bei 1000 bleibt.

Welches Muster kannst du erkennen?
:::

<br>

```{r ui, echo = FALSE}
fluidPage(
    sidebarLayout(
        sidebarPanel(
            sliderInput("reps",
                        "Stichprobenziehungen",
                        min = 1,
                        max = 2000,
                        value = 1000),
            sliderInput("size",
                        "Stichprobengr√∂√üe",
                        min = 0,
                        max = 200,
                        value = 50,
                        step = 5),
            sliderInput("bins",
                        "binwidth",
                        min = 0.01, 
                        max = 0.05, 
                        value = 0.02,
                        step = 0.01),
            actionButton("reload", "Neu generieren")
        ),
        mainPanel(
           plotOutput("distPlot"),
           textOutput("sd")
        )
    )
)

```

```{r server, context = "server"}

  rv <- reactiveValues()
  
  observeEvent(c(input$reload, input$size, input$reps), {
      rv$samples <- rep_sample_n(bowl, 
                                 size = input$size, 
                                 reps = input$reps)
      rv$props <- rv$samples |> group_by(replicate) |>  
        summarize(red = sum(color == "red")) |>  
        mutate(prop_red = red / input$size)
      
      rv$sd <- rv$props |> summarize(sd = sd(prop_red)) |> pull(sd)
      })
  
    output$distPlot <- renderPlot({
      
      ggplot(rv$props, aes(x = prop_red)) +
        geom_histogram(binwidth = input$bins, boundary = 0.4, color = "white") +
        coord_cartesian(xlim = c(0.05, 0.65)) +
        labs(x = paste0("Anteil von roten Kugeln aus ", as.character(input$size)),
             title = "Verteilung der Anteile",
             subtitle = paste0(input$reps, " Stichproben")) 
    })
    
    output$sd <- renderText({
      paste0("Stichprobenvariation (Standardabweichung der Verteilung): ", round(rv$sd[1], digits = 2))
      })

```

```{r learningcheck4}
quiz(
  caption = "Learning Check",
  learnr::question_text(
    text = "Welches Muster hast du beim Ver√§ndern der Stichprobengr√∂√üe bemerkt?", 
    placeholder = "Musterl√∂sung erscheint beim Einreichen der Antwort...",
    answer_fn(function(x) correct()),
    correct = "Die Standardabweichung der Stichprobenkennwerteverteilung nimmt ab, wenn die Stichprobengr√∂√üe steigt. Zun√§chst nimmt die Verteilung einen breiten Wertebereich ein bei geringer Stichprobengr√∂√üe, bis sie schlie√ülich relativ schmal wird. In anderen Worten, es gibt weniger Einfluss der Stichprobenvariation und die Verteilung zentriert sich enger um einen bestimmten Wert. "
    )
)
```

Wir k√∂nnen also feststellen: Wenn die Stichprobengr√∂√üe steigt, werden unsere Sch√§tzer der wahren Proportion immer akkurater.

Theoretisch bis zu dem Punkt, wo die Stichprobe so gro√ü ist, dass sie alle 2400 Kugeln auf einmal zieht und damit den wahren Anteil roter Kugeln automatisch immer richtig bestimmt.

```{r learningcheck5}
quiz(caption = "Learning Check",
     question_radio("Wenn wir die Stichprobengr√∂√üe erh√∂ht haben, wie hat sich die Varianz der Proportionen roter Kugeln ver√§ndert?",
     answer("Die Proportionen variierten weniger", correct = TRUE),
     answer("Die Proportionen variierten mehr"),
     answer("Die Varianz der Proportionen blieb unver√§ndert"),
     allow_retry = TRUE
     ),
     question_radio("Welches Ma√ü haben wir verwendet, um zu quantifizieren wie sehr die 1000 Proportionen variierten?",
                    answer("Die Varianz"),
                    answer("Die Standardabweichung", correct = TRUE),
                    answer("Den Mittelwert"),
                    answer("Die Summe"),
                    answer("Den Interquartilsabstand"),
                    allow_retry = TRUE)
)
```

## Terminologie

Jetzt, wo du ein intuitives Verst√§ndnis von der Stichprobenziehung bekommen hast, k√∂nnen wir den Konzepten, die du eben gesehen habst, Fachbegriffe zuordnen.

Die ersten Begriffe haben mit **Populationen** zu tun.

### Populationen

1.  Eine **Population** ist eine Sammlung von Individuen oder Beobachtungen, an denen wir Interesse haben.
    Mathematisch kann die Gr√∂√üe der Population mit einem gro√üen $N$ notiert werden.

2.  Ein **Populations-Parameter** ist eine numerische Zusammenfassung √ºber die Population, die wir nicht kennen, aber gerne kennen w√ºrden.
    Beispielsweise k√∂nnte der Parameter ein Mittelwert sein wie die mittlere Gr√∂√üe aller Kanadier:innen.
    Oft wird der Parameter auch als der unbekannte "wahre Wert" bezeichnet und tr√§gt allgemein den griechischen Buchstaben $\theta$ (Theta).

3.  Ein **Zensus** ist eine ersch√∂pfende Aufz√§hlung aller $N$ Individuen in der Population.
    Nur damit kann der Populations-Paramater *exakt* bestimmt werden.
    Nat√ºrlich wird das immer zeit-, energie- und geld-intensiver je gr√∂√üer $N$.

Die **Population** in unserer Stichprobenziehungs-Aktion wird durch die $N = 2400$ Kugeln in der Schale dargestellt.

Der **Populations-Parameter** ist uns noch unbekannt, aber wir k√∂nnen den wahren Anteil roter Kugeln in der Population berechnen, da wir in `bowl` eine ersch√∂pfende Liste aller Kugeln haben!
(**Zensus**)

::: aufgabe
Berechne die wahre Proportion roter Kugeln in der Population!
Nutze daf√ºr `summarize()` und *z√§hle* die Anzahl *roter Kugeln*. Gebe diese weiter in eine `mutate()` Funktion und berechne den Anteil an roter Kugeln von 2400 Kugeln. 

(Das ist normalerweise nicht m√∂glich, da normalerweise keine Liste vorliegt mit den Werten aller Individuen der Population, aber in diesem Lehrbeispiel geht das)
:::

```{r theta, exercise = TRUE, exercise.cap = "wahre Proportion roter Kugeln"}
bowl
```

```{r theta-hint}
# f√ºge die entsprechenden Argumente ein:
bowl |>
  summarize(red = sum()) |>
  mutate(prop_red = )
```

```{r theta-solution}
bowl |>
  summarize(red = sum(color == "red")) |>
  mutate(prop_red = red / 2400)
```

```{r truepercent}
question_numeric("Wie viel Prozent der Population sind rote Kugeln? (Zahl von 0 - 100)",
                 answer(37.5, correct = TRUE))
```

An diesem Punkt k√∂nntest du dich fragen, wenn wir den wahren Populations-Parameter so einfach bestimmen konnten, warum haben wir dann √ºberhaupt Stichproben gezogen?
Gute Frage!
Normalerweise w√ºrde man in einer solchen Situation, wo ein **Zensus** der Population m√∂glich ist, auch nicht anfangen Stichproben zu ziehen.
Die simulierte Stichprobenziehung in diesem Tutorial soll einfach ein Beispiel daf√ºr sein, wie es im echten Leben abl√§uft.
Wir haben die Simulationen durchgef√ºhrt, um folgende Konzepte zu studieren:

-   den Effekt von *Stichprobenvariation* auf unsere Sch√§tzer
-   den Effekt von *Stichprobengr√∂√üe* auf *Stichprobenvariation*!

Insbesondere bei Umfragen wird manchmal nicht nur die Populationsgr√∂√üe $N$ zu gro√ü sein, um einen **Zensus** durchzuf√ºhren, manchmal wissen wir nicht einmal, wie gro√ü sie ist.

Gehen wir zum n√§chsten Oberbegriff: **Stichprobenziehung** (*Sampling*)

### Stichprobenziehung

-   *Sampling* ist der Akt des Ziehens einer Stichprobe aus der Population, was wir normalerweise nur tun, wenn es nicht m√∂glich ist, einen Zensus durchzuf√ºhren.
    Mathematisch notiert wird die Stichprobengr√∂√üe mit einem kleinen $n$, im Gegensatz zu einem gro√üen $N$ f√ºr die Populationsgr√∂√üe.
    Normalerweise ist $n$ sehr viel kleiner als $N$, weshalb *Sampling* eine viel g√ºnstigere Alternative ist als einen Zensus durchzuf√ºhren.

-   Eine **Punktsch√§tzung**, auch bekannt als Stichprobenkennwert, ist eine *summary statistic* aus einer gezogenen Stichprobe, die als Sch√§tzer f√ºr den unbekannten Populationsparameter verwendet wird.
    Mit *summary statistic* sind Ma√üe wie Mittelwert, Proportion oder Standardabweichung gemeint.

Zuvor haben wir also *Sampling* durchgef√ºhrt mit $n = 50$ und als wir die Proportion in der Stichprobe errechnet haben, haben wir einen **Punktsch√§tzer** f√ºr die wahre Populations-Proportion generiert.

In der Statistik ist es eine Konvention, Sch√§tzungen mit einem Dach zu versehen.
Wenn die Populations-Proportion $p$ hei√üt, ist die Stichproben-Proportion $\hat p$.

Jetzt verstehst du die Zusammenh√§nge von Stichprobe, Population und Sch√§tzungswerten! 

## Learnings

So hast du heute abgeschnitten:

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Heute hast du gelernt, wie der wahre Wert, die Stichprobengr√∂√üe und die Stichprobenkennwertverteilung in Zusammenhang stehen.
Mit diesem Grundlagenwissen wird es dir leichter fallen die inferenzstatistischen Tests, wie den *t-Test*, den *Chi-Test* und auch *Regressionen*, zu verstehen.

## Hash generieren

Wenn du mit deinen Antworten im Tutorial zufrieden bist, generiere dir deinen Hash-Code, kopiere ihn und lade ihn bei der entsprechenden Abgabe auf Moodle hoch!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui(ui_before = NULL)
```

### [**Moodle-Kurs √∂ffnen**](https://moodle.uni-kassel.de/course/view.php?id=19918)


## Credit

Dieses Tutorial wurde von Lukas Bruelheide geschrieben und von Marie Klosterkamp reviewed.

### Literatur
