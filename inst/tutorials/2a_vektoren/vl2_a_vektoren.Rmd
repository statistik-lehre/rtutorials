---
title: "Vektoren"
output:
  learnr::tutorial:
    language: de
    css: css/boxes.css
    fig_caption: no
tutorial:
  id: vektoren
  version: 1
runtime: shiny_prerendered
bibliography: ref.json
link-citations: TRUE
description: Einführung in Assignment und Vektoren
resource_files:
- css/boxes.css
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
library(learnr)
library(modeest)
knitr::opts_chunk$set(echo = FALSE)
```

## Lernziele

Im letzten Tutorial hast du dich spielerisch mit der allgemeinen
Syntax von Funktionen in R beschäftigt. Dieses Tutorial baut darauf auf und beantwortet folgende Fragen:

-   Wie erstelle ich ein Objekt in R? (Assignment)

-   Was ist das Environment?

-   Wozu werden Vektoren benötigt?


## kurze Wiederholung

```{r q1, echo=FALSE}
question("Wie kennzeichnet man einen Kommentar in R?",
  answer("`#` mit der Raute", correct = TRUE),
  answer("`;` mit einem Semikolon "),
  answer("`>` mit dem Größer-als-Zeichen"),
  answer(" `“` mit Anführungszeichen"),
  allow_retry = TRUE
)
```

Außerdem:

-   Text wird durch Anführungszeichen `"` gekennzeichnet. Auch einfache Anführungszeichen `'` sind möglich.

-   Argumente werden durch Kommata getrennt (Argument1 `,` Argument2)

-   Laden von Paketen mit `library()`

-   Installieren von Paketen mit `install.packages()`

-   Hilfe wird über F1 / `?`Funktionsname / `help()` aufgerufen

-   R Skript = Drehbuch/ Choreografie für Code 

-   R Notebook = gut lesbare Mischung aus Code, Erläuterungen und
    Ergebnissen

## R als Taschenrechner

:::{.aufgabe}
Fangen wir einfach an:

Berechne 2 + 3 im Codeblock!
:::

```{r rechner, exercise = TRUE}

```

```{r rechner-solution}
2 + 3
```

Das Ergebnis wird nicht gespeichert, sondern einfach nur ausgegeben - es
ist *printed and lost*.

Aber wie lässt sich das Ergebnis speichern, um damit im weiteren Verlauf
zu arbeiten?

Das funktioniert folgendermaßen:

```{r assignment_x, exercise = TRUE}
x <- 2 + 3
```

Hier wird beim Ausführen des Codes nichts ausgegeben. Das
liegt daran, dass der Wert von `2 + 3` in der Variable `x` gespeichert
wurde. 

:::{.aufgabe}
Um zu sehen, was die Variable `x` nun enthält, tippe einfach `x`:
:::

```{r x, echo = FALSE}
x <- 2 + 3
```

```{r x_print, exercise = TRUE, exercise.setup = "x"}

```

```{r x_print-solution}
x
```

Sehr gut! Im nächsten Abschnitt erfährst du mehr über die Zuweisung mit
`<-`.

## Assignment

Mithilfe des *assignment operators* `<-` bekommt ein Name einen Wert
zugewiesen. So können Variablen erstellt werden.

``` r
x <- 2 + 3
# Variablenname <- Wert
```

::: grau
#### Verbalisierung

Oft ist es hilfreich, Code zu verbalisieren. Hier sind einige
Möglichkeiten, wie der Pfeil ausgesprochen werden kann:

Lies in deinem Kopf:

-   `x` *bekommt den Wert von* `2 + 3`

-   und von rechts nach links, in der Pfeilrichtung:

    `2 + 3` *wird auf* `x` *geschrieben*.
:::
<br>

::: aufgabe
Multipliziere nun `x` mit 2!
:::

```{r y_creation, exercise = TRUE, exercise.setup = "x"}

```
<br>
```{r y_creation-solution}
x * 2
```
<br>

::: aufgabe
Speichere nun `x * 2` in einem neuen Objekt `y`!
:::

```{r y_saving, exercise = TRUE, exercise.setup = "x"}

```

```{r y_saving-solution, exercise.setup = "y_saving"}
y <- x * 2
```

::: blau-nb
**Tipp**: Nutze die Tastenkombination `Alt` + `-`, um den
*assignment operator* `<-` zu erzeugen!

Das hat den Vorteil, dass der Pfeil automatisch von Leerzeichen umgeben
wird.
:::
<br>

::: gelb

**Achtung mit Leerzeichen:**

`x < -2 + 3` hat eine sehr andere Bedeutung als   `x <- 2 + 3`.

Ersteres heißt: "Ist `x` kleiner als `-2 + 3`?", letzteres bedeutet:
"Definiere `x` als `2 + 3`".
:::
<br>

::: aufgabe
Lasse dir nun `y` ausgeben!
:::

```{r y_print, exercise = TRUE, exercise.setup = "y_saving-solution"}

```


::: grau-nb
Übrigens:

Der Pfeil funktioniert auch in umgedrehter Form: `5 -> x`, das ist aber
unkonventionell und wird schnell unübersichtlich.
:::

### printed and lost

Wie bereits erwähnt ist alles, was nicht benannt wird, "*printed and
lost*".\
Das heißt, die Rechenaufgabe wird ausgewertet und das Ergebnis
ausgegeben, aber nirgends gespeichert.

```{r printed, echo=TRUE}
5 + 5       # Ergebnis ist "printed and lost"
x <- 5 + 5  # Ergebnis speichern
x           # Ergebnis ausgeben
```

### Überschreibung

Bereits existierende Variablen werden ohne Warnung überschrieben, wenn
sie neu definiert werden:

```{r overwrite, exercise = TRUE, eval=TRUE}
z <- 1
z
z <- 5
z
```

### Hinweise zu Objektnamen

#### formale Kriterien

-   R akzeptiert keine Leerzeichen in Objektnamen.

-   Namen dürfen nicht mit einer Zahl beginnen.

-   Namen sind *case-sensitive*, das heißt, Groß- und Kleinschreibung
    spielt eine Rolle. (x ≠ X)

#### stilistische Kriterien

Gute Namen:

-   **sind leicht zu tippen**

-   verwenden **konsistent** `_` oder `.` oder `-` als Leerzeichen

-   sind **konsequent** kleingeschrieben (hilft Verwechslungen zu vermeiden)

-   sind nicht identisch mit internen Objekten

    -   `T` und `F` sind z.B. schlechte Namen (stehen intern für TRUE
        und FALSE)

::: vorteile
##### Beispiele guter Namen

``` r
a
alter
alter_gruppe_1
alter-gruppe-1
alter.gruppe.1
```
:::

::: nachteile
##### Beispiele schlechter Namen

``` r
aLteR
ALTER
Alter_gruppe.1
```
:::

## Environment

Environment bedeutet Umgebung. Hier erscheinen alle definierten Objekte,
und alles was sich in der Umgebung befindet, kann von R verwendet
werden.

![](images/environment.png)

Es können natürlich nur Objekte aufgerufen werden, die auch vorher definiert
`<-` wurden und deswegen in der Umgebung verfügbar sind. Ansonsten
bekommst du folgenden Fehler:

```{r def, message=TRUE, warning=TRUE, exercise=TRUE, exercise.caption="Fehlermeldung"}
obj           # nicht vorher definiert, deswegen Fehler
```

Das lässt sich dadurch lösen, dass du das Objekt vorher definierst:

```{r def2, exercise = TRUE}
obj <- 100
obj
```

### wichtige Einstellung

![](images/settings.png)

::: aufgaberstudio

Setze bitte die RStudio-Einstellungen unter Tools / Global Options
auf diese Werte! Dadurch wird das Environment mit dem Beenden von
RStudio automatisch gelöscht und nicht zwischen Sitzungen gespeichert.
:::
<br>
Das soll dazu animieren, alle Objekte die benutzt werden auch
tatsächlich selbst zu definieren.

Das dient der Replizierbarkeit - Stell dir vor, du hast `x` gar
nicht definiert, die Berechnungen werden aber trotzdem ohne Warnung
ausgeführt, weil noch ein anderes `x` aus der letzten Sitzung
zwischengespeichert ist. Dann bekommst du falsche Ergebnisse und merkst
es eventuell nicht.


## Vektoren

Es ging bereits die ganze Zeit um Vektoren. Zum Beispiel
ist `obj` ein Vektor mit der Länge 1 - enthält also nur **eine** Zahl.

```{r, echo=TRUE}
obj <- 100
obj
```

Vektoren sind die elementarste Kategorie von Objekten in R und werden
sehr häufig gebraucht. Andere Objekttypen werden in einem eigenen
Tutorial vorkommen und bauen darauf auf.

Das Nützliche an einem Vektor ist, dass er mehrere Werte enthalten kann.

Beispielsweise die Ausprägungen des Merkmals "Alter" bei einer Befragung
von 4 Personen:

```{r, echo=TRUE}
alter <- c(20, 23, 50, 11)
alter
```

### neue Funktion: `c()`

Um Vektoren zu erstellen, die mehr als einen Wert enthalten, brauchst du die Funktion `c()`.

-   *c* wie *combine* oder *concatenate* (verketten)

-   kombiniert mehrere Werte zu einem Vektor

-   wie in jeder Funktion sind die Argumente (Werte) durch Kommata
    getrennt

-   das Dezimalzeichen in R ist der Punkt!

::: aufgabe
**1.** Verkette 1.5, 2.5 und 3 mithilfe von `c()`!
:::

```{r concatenate, exercise = TRUE}
c()
```

```{r concatenate-solution}
c(1.5, 2.5, 3)
```

::: aufgabe
**2.** Mit `c()` lassen sich auch mehrere Vektoren aneinander binden. Kombiniere `x`, `y` und `z` zu einem neuen Vektor!
:::

```{r vectorc, exercise = TRUE}
# x, y und z definieren
x <- 5     
y <- 2 * x
z <- y / x

# x, y und z zu einem neuen Vektor verketten
c()

```

```{r vectorc-solution}
c(x, y, z)
```

Sehr gut! Als nächstes wird es daraum gehen, wie das Rechnen mit Vektoren
funktioniert.

## Rechnen mit Vektoren

Betrachte das folgende Beispiel. Welcher Schluss kann daraus
über das Rechnen mit Vektoren gezogen werden?

```{r vecmath, exercise = TRUE}
vec <- c(1, 2, 3) 
vec 
vec + 1
```

Die Rechenoperation wird mit jedem einzelnen Element des Vektors
durchgeführt!

Als Ergebnis steht ein neuer Vektor der die Ergebnisse der einzelnen
Berechnungen enthält. `vec` wird dadurch nicht verändert.

Dass Funktionen (wie z.B. `+`) auf jedes Element eines Vektors
angewendet werden, ist eine fundamentale Erkenntnis, die du noch sehr
häufig benötigen wirst. Das Konzept dahinter heißt **Vektorisierung**
und ist ein Bestandteil der Mächtigkeit von R.

```         
vec + 10
```

```{r vecq}
question( "Was erwartest du als Ergebnis dieser Berechnung?",
  answer("Einen Vektor der Länge 1 mit dem Wert 15"),
  answer("Einen Vektor der Länge von `vec`, wo jedes Element mit 10 addiert 
   wurde", correct = TRUE),
  answer("Einen leeren Vektor"),
  answer("Einen Vektor mit 13 Elementen: 3 aus dem ursprünglichen plus 10 dazugefügte"),
  allow_retry = TRUE,
  random_answer_order = TRUE
)
```

Im folgenden ein paar weitere Beispiele.

### Vektor + Vektor

Was passiert, wenn zwei Vektoren gleicher Länge addiert werden?

```{r vecvec-setup}
vec <- c(1, 2, 3)
```

```{r vecvec, exercise = TRUE}
vec + vec
```

::: infobox
Die Rechenoperation wird jeweils zwischen den Elementen durchgeführt,
die an der gleichen Position stehen. 

(1 + 1, 2 + 2, 3 + 3)

(erstes Element + erstes Element, zweites + zweites Element, drittes + drittes ... )
:::

### Vektoren unterschiedlicher Länge

```{r recycl, exercise = TRUE}
v <- c(1, 2, 3, 4, 5, 6)
z <- c(1, 2)
v + z
```

::: infobox
Wenn zwei Vektoren unterschiedlicher Länge verrechnet werden, wird der
kürzere Vektor automatisch so lange wiederholt, bis die Länge des
anderen Vektors erreicht ist. Dieses Konzept heißt auch **Recycling**.
:::
<br>

Letztlich geschieht dieser Mechanismus auch bei unserem ersten Beispiel
von Rechnen mit Vektor + Zahl (`vec + 1`), weil die Zahl eigentlich auch
nur ein Vektor der Länge 1 ist.

### Warnmeldung

Entsteht beim Recycling ein "Überstand", weil die beiden Vektoren keine
Vielfachen voneinander sind, wird die Berechnung trotzdem durchgeführt,
allerdings mit einer Warnung:

```{r warn, exercise = TRUE, warning=TRUE, exercise.caption="Warnmeldung"}
v <- c(1, 2, 3, 4, 5, 6)
z <- c(1, 2, 3, 4, 5)
v + z
```

Sehr gut! Du hast jetzt bereits die wichtigsten fundamentalen
Bestandteile der Programmiersprache R in Aktion kennengelernt.


## Zahlenreihen

Um eine Zahlenreihe zu erstellen, kannst du den *colon operator* `:` verwenden.

```{r, echo=TRUE}
1:10
```

Der *colon operator* erzeugt als Ergebnis einen Vektor, der eine
ganzzahlige Zahlenreihe enthält.\
Wir könnten das selbe Ziel auch mit `c()` erreichen, was aber sehr
umständlich wäre:

```{r, echo=TRUE}
c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
```
<br>

:::aufgabe
**Anwendung**

Erstelle einen Vektor namens `z`, der eine Zahlenreihe von 1 bis
1000 enthält! 

Lass dir daraufhin `z` ausgeben.
:::

```{r colon, exercise=TRUE, exercise.caption="colon operator"}

```

```{r colon-solution}
z <- 1:1000
z
```

## Textvektoren

Vektoren können nicht nur Zahlen enthalten, sondern unter anderem auch
Text.

Texteingabe wird für durch `"Anführungszeichen"` gekennzeichnet. 
Achtung! Es sollten genau diese Anführungszeichen sein `" "`, die normalerweise bei QWERTZ-Tastaturen mit `Shift` + `2` erreichbar sind. Es darf kein `„ “` oder `» «` sein, da das nicht erkannt wird. 

::: aufgabe
Das ist schon das vierte Tutorial, und du hast noch kein "Hello World"-Programm geschrieben... Das wird jetzt nachgeholt. 

Schreibe ein Programm, das den Text `Hello World!` als Ergebnis ausgibt! 
:::

```{r charvec, exercise = TRUE, exercise.cap = "Hello World!"}

```

```{r charvec-solution}
"Hello World!"
# Erstaunlich einfach, oder?

# Es geht natürlich auch umständlicher mit Zwischenspeichern:
text <- "Hello World!"
text
```

"Hello World" ist ein Textvektor der Länge 1, das heißt, dass er nur ein Element enthält. Sollen mehrere Texte in einem Vektor kombiniert werden, wird wieder `c()` benötigt. 

::: aufgabe
Kombiniere die Texte:

- "Hund"
- "Katze"
- "Maus"

zu einem Vektor namens `tiere`. 

Lasse dir den Vektor dann anzeigen.
:::

```{r char_animals, exercise = TRUE, exercise.cap = "Textvektor erstellen"}

```

```{r char_animals-solution}
tiere <- c("Hund", "Katze", "Maus")
tiere
```

### Länge bestimmen

```{r lengthquiz}
question_numeric("Welche Länge hat der Vektor `tiere`? Anders gesagt, wie viele Elemente enthält er?",
                 answer(3, correct = TRUE),
                 allow_retry = TRUE)
```

Die Länge eines Vektors kann mit der Funktion `length()` bestimmt werden. Jetzt konntest du die Anzahl der Elemente noch selbst zählen, aber die meisten Daten mit denen im Alltag gearbeitet wird, sind dafür zu groß. 

::: aufgabe
Ermittle nun noch einmal auf programmatischem Weg die Länge deines gerade erstellten Vektors 'tiere'! Nutze die Funktion `length()`!
:::

```{r tiere}
tiere <- c("Hund", "Katze", "Maus")
tiere
```

```{r lengthex, exercise.setup = "tiere", exercise = TRUE, exercise.cap = "Länge eines Vektors bestimmen"}

```

```{r lengthex-solution}
length(tiere)
```

### Fehlermeldung: Mathe mit Textvektoren

Solltest du irgendwann mal versuchen, eine numerische Rechnung mit einem Textvektor durchzuführen, gibt R eine Fehlermeldung aus. 

:::aufgabe
Mach dich mit der Fehlermeldung vertraut! 
:::

```{r matherror, exercise = TRUE, exercise.cap = "Fehlermeldung", exercise.setup = "tiere"}
tiere + 1
```

> "non-numeric argument to binary operator"

bedeutet so viel wie: Keine Zahl eingegeben, wo eigentlich eine Zahl für erwartet wurde. Der „binary operator“ ist hier das `+`.

Perfekt! Jetzt bist du gewappnet, falls es dir diese Meldung in Zukunft unterkommen sollte. 


## Atomic vectors

Nun zu einer elementaren Eigenschaft von Vektoren:

Betrachte dazu dieses Beispiel:

```{r coercion, exercise = TRUE}
c(1, 2, 3, 4)
c(1, 2, 3, "vier")  # Die ausgegebenen Zahlen stehen in Anführungszeichen
```

::: infobox
Achtung! Vektoren können immer nur Daten des gleichen Typs enthalten! Also entweder Text oder Zahlen. Dazu wird auf Englisch gesagt, es sind *atomic vectors*. 

Sobald auch nur ein einziges Element eines Zahlen-Vektors Text ist, wird der
ganze Vektor zu einem Textvektor umgewandelt und die Zahlen stehen nicht mehr für
Berechnungen zur Verfügung. Diese automatische Umwandlung heißt *coercion*.
:::
<br>

Der im letzten Abschnitt vorgestellte Fehler
`non-numeric argument to binary operator` entsteht oft, wenn numerische Vektoren irgendwo automatisch in Textvektoren umgewandelt werden. 

::: aufgabe
Führe den Code aus. Die Zahlen in `id` werden in Text *coerced* und die Berechnung schlägt fehl. 

Ändere den Code, so dass die Berechnung fehlerfrei ausgeführt werden kann!
:::

```{r coercion_error, exercise = TRUE, exercise.cap = "Fehler durch Mathe mit Textvektor"}
id <- c(1, 2, 3, "4")
id + 1
```

```{r coercion_error-solution}
id <- c(1, 2, 3, 4)
id + 1

# ohne die Anführungszeichen kann der Text als Zahl erkannt werden.
```

## Datentypen 

### Unterscheidung Typ und Klasse

Als nächstes schauen wir uns die Typen und Klassen von Objekten in R etwas genauer an. 

::: infobox

**Kurzzusammenfassung**

Der **Datentyp** kategorisiert die Objekte nach der Art und Weise, wie sie im Computer gespeichert werden. Also z.B. ob es Text ist, Dezimalzahlen, oder ganze Zahlen. Ein Vektor kann immer nur Daten des gleichen Typs enthalten.

Die **Klasse** eines Objekts hingegen sagt R, wie es damit umgehen soll. Also welche Operationen erlaubt sind. Beispielsweise, dass auf ein Objekt der Klasse "Text" die Methode "Multiplikation" nicht angewandt werden kann, die Methode "zähle die Wörter" aber schon. Teilweise überschneiden sich Datentyp und Klasse. Aber: Es gibt unbegrenzt viele Klassen, jedoch nur eine kleine, feste Anzahl an Datentypen (6 Stück). 
Ein Objekt kann auch mehrere Klassen haben, während es nur ein einziger Datentyp gleichzeitig sein kann. Es gibt unbegrenzt viele Klassen, weil Programmierer\*innen jederzeit neue Klassen erfinden können. 

Auf dem Level, auf dem wir R nutzen ist die ganz genaue Unterscheidung zwischen Typen und Klassen nicht notwendig. Nur gut, es einfach schonal gehört zu haben, da hier manchmal Probleme auftauchen die sich dann meist relativ einfach lösen lassen.

:::

### Die verschiedenen Datentypen


Es gibt *atomic vectors* in insgesamt sechs Datentypen, von denen wir aber nur vier wirklich verwenden. Aber damit du es einmal gesehen hast, werden der Vollständigkeit halber einmal alle gezeigt. 

1. numeric: Typ **integer**
2. numeric: Typ **double**
3. **character**
4. **logical**
5. (complex)
6. (raw)

R sagt dir, welchen **Datentyp** ein Objekt `x` hat, wenn du `typeof(x)` eingibst (siehe unten).

### Zahlen: Unterschied `double` und `integer`

Sowohl `double` als auch `integer` beinhalten Zahlen. Wo ist nun der Unterschied und warum gibt es ihn?


**Double** sind Fließkommazahlen bzw. Dezimalzahlen, auch *floating point numbers*.

**Integer** sind positive und negative ganze Zahlen sowie Null. 
Das ist wichtig zu erwähnen, denn das ist krass: Computer merken sich Zahlen anders als Menschen. Die meisten Menschen denken *dezimal* (also in Zehnerschritten) und Computer *binär* (die klassischen 1 und 0). 

Für den Menschen sieht eine `0.1` so aus: $0.1$ bzw. $\frac{1}{10}$.

Für einen Rechner sieht eine `0.1` so aus: $0.0 \overline{0011}$. 

Rechner können je nach Programmeinstellung und in sehr hardcore Fällen auch aufgrund der Hardware pro Zahl nur  [23](https://de.wikipedia.org/wiki/Einfache_Genauigkeit) bzw. [52](https://de.wikipedia.org/wiki/Doppelte_Genauigkeit) binäre [signifikante Stellen](https://de.wikipedia.org/wiki/Signifikante_Stellen) berechnen. Das entspricht ca 8 bzw. 16 dezimalen Ziffern (*Siehe dazu auch dieses wunderbare [Video](https://www.youtube.com/watch?v=PZRI1IfStY0)). Danach wird die Zahl einfach abgeschnitten - mit fatalen Folgen.

::: infobox
R kann erst mal "nur" 16 Dezimalstellen nach dem Komma genau berechnen (vorausgesetzt, du befindest dich nicht auf uralter Hardware mit 32-Bit, dann wären es 8). Wenn mehr Präzision benötigt wird, können dafür aber problemlos spezielle Pakete verwendet werden. 
:::

<br>
<details>
<summary><a>▼ \* Rumgenerde bzgl. des Datentyps double.
</a></summary>

Ob 23 oder 52 binäre signifikante Stellen hat was mit einen Programmeinstellungen zu tun. Du wurdest beim Runterladen gefragt, ob du eine 32 oder 64 bit Version von R möchtest und du wirst 64 gewählt haben. Im grunde hast du da ausgewählt, wie präzise R Zahlen abbilden kann. Falls du das gegenchecken möchtest, tippe `sessionInfo()` in deine Konsole. In der zweiten Reihe steht hinter `Platform:` dein Betriebssystem sowie die Zahl der Bits, für die du dich entschieden hast.

Das Format von Zahlen, die mit 32 Bit gespeichert sind heißt auch *"Single-precision floating-point format"*. Das wird dir in der freien Wildbahn eher nicht begegnen. Das Format von mit 64 Bit gespeicherte Daten heißt *"Double-precision floating-point format"*. Hier schließt sich der Kreis, dennn exakt das sagt der Datentyp **double`**.

Für den Alltag reicht zu merken: **double** bedeutet Kommazahl (mit einer bestimmten Präziszion).

</details>

Während für den Menschen die Dezimalzahl $0.1$ eben so aussieht: $0.1$ sieht sie für den Rechner (vereinfacht) so aus: $0.000110011001100110011001100110011001100110011$ was umgerechnet wiederum $0.09999999999999431566$. Genauer kann dein PC 0.1 nicht abbilden. Punkt. 

Im Alltag rundet R das ganz freundlich, ist also häufig echt egal:

```{r double, exercise = T}
0.1 + 0.2
```

"Ist doch alles so wie ich das auch per Hand rechnen würde!"

Ja, stimmt. R hat gut gerundet, was für diesen Anwendungsfall auch wirklich total okay ist!. Was passiert allerdings, wenn du R fragst: "Ist 0.1 + 0.2 ganz genau gleich 0.3?"(damit R es versteht, bitte so formulieren: `0.1 + 0.2 == .3`)?

```{r double2, exercise = T}
0.1 + 0.2 == 0.3
```

HUCH?

und weiter: 

```{r double3, exercise = T}
(0.1 + 0.2) - 0.3

```

Das ist eine absurd kleine Zahl, aber sie ist eben unterschiedlich von Null, was sie genau genommen nicht sein dürfte.

Bei den Rechenoperationen, die wir durchführen reicht diese Genauigkeit aus. Wenn es genauer sein soll, auch bei kleineren Zahlen (im Bankenwesen würden große Verluste zustande kommen, wenn so ungenau gerundet wird), gibt es `integer` Zahlen. Die heißen so, weil sie eben integer sind. Ganze Zahlen eben. Grundsätzlich geht R von Fließkommazahlen aus. Wenn du eine integer Zahl möchtest, musst du das R ganz konkret sagen. Das machst du mit einem großen `L` an der Zahl ohne Leerzeichen dazwischen.

```{r typen_num, exercise = T}
vec_dou <- c(1, 2, 3)
vec_int <- c(1L, 2L, 3L)

# Gib der Vollständigkeit halber folgende Zeile einmal ohne Hashtag in deine Konsole ein:
# vec_schmu <- c(1 L, 2 L, 3 L) 
# hier wird ein Fehler geworfen werden. Dieser Vektor dient zum verdeutlichen, dass das L direkt an die Zahl anschließen MUSS

# Nun schauen wir uns die Datentypen an:
typeof(vec_dou)
typeof(vec_int)
```

Okay, also Zusammenfassend lässt sich sagen: Es gibt zwei Typen von Zahlen. Ganze Zahlen bzw. `integer` und Fließkommazahlen bzw `double`. So weit, so einfach.

Sollte, warum auch immer, der Fall eintreten, das du den einen Typen in den anderen umwandeln möchtest, ist das natürlich auch möglich: Die Funktionen `as.integer()` bzw. `as.double()` sind hier deine Freunde.

```{r typen_num2, exercise = T, exercise.setup = "typen_num"}
typeof(as.integer(vec_dou))
typeof(as.double(vec_int))
```

So weit so gut. Was passiert nun aber, wenn im `double` Vektor auch tatsächlich Kommazahlen gespeichert sind?

```{r typen_num3, exercise = T, exercise.setup = "typen_num"}
# zuerst vec_dou neu definieren
vec_dou <- c(1, 2.4, 3.5, 4.5, 5.6, 6.9, 7)
typeof(vec_dou)
as.integer(vec_dou)
typeof(as.integer(vec_dou))
```

Zuerst fällt auf: Die Umwandlung hat trotzdem funktioniert und alle Zahlen wurden auf eine ganze Zahl gerundet.

Dann fällt auf: Puh! Alle nach unten gerundet! Gut beobachtet. So verwandeln Rechner `doubles` in `integers`. Isso.

Das war jetzt sehr theoretisch, aber die Zahlentypen sind geschafft! Das war das komplizierteste (und spannedste). Jetzt solltest du folgendes Meme verstehen:

![](images/integer.jpg){width="50%"}

#### Buchstaben in R: Der Datentyp `character`

Dieser Datentyp sind literally Zeichenfolgen. Du sagst R, dass es das als *character* behandeln soll, indem du Inhalte in Anführungszeichen setzt. Dann ist es R auch egal, WAS du darein schreibst.

```{r character, exercise = T}
vec_cha <- c("Hund", "Katze", "Maus")
# probiere auch einmal, was passiert, wenn du den Vektor versuchst ohne Anführungszeichen zu speichern, also:
# vec_schmu <- c(Hund, Katze, Maus)

# Typ herausfinden:
typeof(vec_cha)
```

Juhuu, soweit so logisch. Aber wie ist das mit Zahlen?

:::aufgabe
Finde den Datentyp der Vektoren heraus und konvertiere den `double` und `charakter` Vektor in das jeweilige andere (neu: `as.character()`). Betrachte auch explizit den vierten Eintrag des 1. Vektors.
:::

```{r character2, exercise = TRUE}
vec_cha <- c("1", "2", "3", "vier")
vec_num <- c(5, 6, 7)

```

```{r character2-solution}
vec_cha <- c("1", "2", "3")
vec_num <- c(4, 5)

typeof(vec_cha)
typeof(vec_num)

as.double(vec_cha)
as.character(vec_num)
```

Also: Zahlen, die wirklich nur Zahlen sind und als *charakter* gespeichert sind lassen sich problemlos numerisch verwenden. Ist allerdings ein geschriebenes Wort dazwischen wird es in ein `NA`, also `Not Available` verändert.

#### Logische Werte: `logical`

R kennt zwei logische Werte: Wahr und Falsch, bzw. `TRUE` und `FALSE` oder `T` und `F` oder auch `1` und `0`. Die sind meist vor allem interessant, wenn Werte gefiltert werden. Dazu gibt es im nächsten Tutorial einen ersten Einblick.

```{r logical, exercise = TRUE}
vec_log <- c(T, T, F) 
# Achtung: Wenn du die Buchstaben in Anführungszeichen steckst, kommt ein charakter Vektor raus
vec_cha <- c("T", "T", "F")
vec_log_num <- c(1, 1, 0)

typeof(vec_log)
typeof(vec_cha)
typeof(vec_log_num)

# Auch hier lässt sich fröhlich transformieren
as.character(vec_log)
as.double(vec_log)

as.logical(vec_cha)
as.double(vec_cha)
# kannst du erklären, warum das nicht klappt? und wie könnte es klappen?

as.logical(vec_log_num)
as.character(vec_log_num)
```

<details>

<summary><a>▼ \* Wer noch nicht genug von Datentypen hat: `complex` und `raw`</a></summary>

![](images/complex.jpg){width="50%"}

Daten des Typen `complex` sind, wie der Name schon sagt: [Komplex](https://de.wikipedia.org/wiki/Komplexe_Zahl). Das bedeutet: [Reelle](https://de.wikipedia.org/wiki/Reelle_Zahl) plus [imaginäre](https://de.wikipedia.org/wiki/Imagin%C3%A4re_Zahl) Zahlen.

Daten des Typen `raw` zeigen binäre Zahlen umgerechnet als Hexadezimalzahlen an.

Wenn du, warum auch immer, das mal brauchen solltest: natürlich funktionieren auch hier die Funktionen `as.complex()` bzw. `as.raw()`.

Beide Typen sind mir in meiner kompletten R Laufbahn noch nie in der Praxis über den Weg gelaufen. Solltest du ihnen begegnen, kannst du sie jetzt aber einordnen.

</details>

</br>

#### Zusammenfassung Typen

Nochmal zusammengefasst: Es gibt 6 Datentypen (2 numerische: `double` (mit Komma), `integer` (ohne Komma), Buchstaben (`character`), logische Werte (`logical`), Zahlen, die genau genommen keine richtigen Zahlen sind (`complex`) und irgendwie komisch dargestellte binärcodes (`raw`)). Welchen Typ die Daten haben kann mit der Funktion `typeof()` in Erfahrung gebracht werden und unter bestimmten Voraussetzungen lassen sich die Typen auch ineinander übersetzen `as.neuertyp()`. Ob ein bestimmter Typ vorliegt, findest du mit `is.datentyp()` heraus.

## Klassen

Es gibt sehr viele Klassen in R. Und manche Funktionen funktionieren oder funktionieren nicht oder werfen andere Ergebnisse aus, abhängig davon, in welcher Klasse von Objekt die Daten stecken. Häufig werden Klassen explizit festgelegt. Wenn das nicht der Fall ist, haben die Objekte ein implizites Klassenattribut und manchmal einfach den Datentyp.

Klingt kompliziert? Ist es auch. Und das ist total okay. Wir bringen gemeinsam Schritt für Schritt etwas Licht ins Dunkel.

In einem Objekt können mehrere Daten gespeichert werden. Die Klasse sagt nun etwas darüber aus, wie das Objekt intern organisiert ist.

Die Funktion `class()` gibt aus, welche Klasse das besagte Objekt hat.

### Eine Dimension

#### Vektor

![](images/victor.jpg){width="25%"}

Ein Vektor ist die einfachste Datenstruktur. Es ist quasi eine Aneinanderreihung von Zahlen. Einfache Zahlen werden als Vektor mit einem Eintrag gewertet. Wenn die Daten in einem Vektor Objekt organisiert sind, wirft die Funktion `class()` im Groben und Ganzen den Typen der darin gespeicherten Daten aus.

:::aufgabe
Finde für die aufgeführten Vektoren den Datentyp und die Objektklasse heraus. Mach dich mit den Gemeinsamkeiten und Unterschieden vertraut.
:::

```{r class1, exercise = TRUE}
# im Folgenden werden aus oben genannten Gründen nur die vier Häufigsten Datentypen besprochen
vec_dou <- c(0, 1, 2.3, -4, -5.6)
vec_int <- c(0L, 7L, -8L)
vec_cha <- c("das", "sind", "ein paar Worte")
vec_log <- c(T, F, T, F)
```


```{r class1-solution}

typeof(vec_dou) # Datentyp
class(vec_dou)  # Klasse

typeof(vec_int) # Datentyp
class(vec_int)  # Klasse

typeof(vec_cha) # Datentyp
class(vec_cha)  # Klasse

typeof(vec_log) # Datentyp
class(vec_log)  # Klasse
```

Huch? Datentyp `double` und Klasse `numerisch` - wie kommt das denn zustande?

Tatsächlich liegt die unterschiedliche Antwort in der unterschiedlichen Frage: 
- `typeof()` fragt nach dem grundlegenden **Datentyp** (also wie ist die Zahl im Rechner repräsentiert? $\to$ In diesem Fall eben als Fließkommazahl mit doppelter Genauigkeit) während 
- `class()`die Klasse des Objekts anfragt, die angibt, wie R damit umgehen soll. 

(Das ist eine gröbere Unterteilung, es reicht die Info, dass es numerische Daten sind (und eben keine Buchstaben o.ä.)).

Und wie ist es bei gemischten Vektoren?

```{r class2, exercise = T}
# ein gemischter Vektor
vec1 <- c(0, 2.3, -4, "manche Worte", TRUE, FALSE, 9L)

typeof(vec1)
class(vec1)

# ein gemischter Vektor ohne characters
vec2 <- c(0, 2.3, -4, TRUE, FALSE, 9L)

typeof(vec2)
class(vec2)

# ein gemischter Vektor ohne characters und doubles
vec3 <- c(TRUE, FALSE, 9L)

typeof(vec3)
class(vec3)

# Huch, integer?
# Wir erinnern uns: 1 = TRUE, 0 = FALSE; integer sind ganze Zahlen; 0 und 1 sind ganze Zahlen
# einmal prüfen:
vec3 + 1

# Das Ergebnis zeigt ganz klar, das TRUE und FALSE als 1 und 0 und deswegen als integers behandelt werden
```

Ein Vektor hat 1 Dimension. Nun werden Objekttypen besprochen, die mehr als 1 Dimension haben.

#### Factor

<details>
<summary><a>▼ \* Für die ganz fleißigen.
</a></summary>

Factoren in R sind eine feine Angelegenheit. Auf dem ersten Blick recht kompliziert und unintuitiv ermöglichen sie dem geübten Händchen vor allem hintenraus doch ein schnelles und einfaches Arbeiten. **Bitte trotz gleichem wording im Kopf konzeptuell trennen von dem statistischen Konzept Faktor aus der Faktorenanalyse, das ist was grundlegend anderes!** (Deswegen wird in diesem Kurs der Factor in R auch mit c geschrieben.)

Ein Factor ist genau genommen ein Spezialfall eines Vektors für **kategoriale** Daten (also **nominalen** Daten, die sich in nicht hierarchisch sortierbare Gruppen einteilen lassen (z.B. Farben, Städte, Studiengang etc.)) und **ordinalen** Daten (also denen, wo sich die Gruppen zwar hierarchisieren lassen, die Abstände aber nicht interpretierbar sind (z.B. Rangfolgen von Lieblingssüßigkeiten, Filmen etc., Bildungsniveau, Plätze bei einem Sportwettkampf etc.)).

Der einfachste Factor sieht aus wie ein Vektor:

```{r class_fac1, exercise = TRUE}
# Für dieses Beispiel mit Schulabschlüssen
vec <- c("abi", "real", "ba", "real", "ba")
fac <- factor(c("abi", "real", "ba", "real", "ba"))

vec
fac

typeof(vec)
typeof(fac)
class(vec)
class(fac)
```

Huch? Facort mit Typ `integer`, obwohl es doch zweifelsfrei `character` sind?

In R wird ein Factor intern als ganzzahliges (`integer`) Vektorobjekt repräsentiert. Wenn du einen Faktor erstellst, ordnet R den verschiedenen Kategorien im Faktor Ganzzahlen zu, die als Indizes oder Levels bezeichnet werden.

Zu den schönen Facts von Factoren: Es ist möglich, die Inhalte des Factors zu sortieren und ihnen Labels zuzuweisen. Ersteres vereinfacht bestimmte Statistiken später, zweiteres vereinfach viele Darstellungsmöglichkeiten.

```{r class_fac2, exercise = TRUE, exercise.setup = "class_fac1", exercise.cap = "ordered factor"}
fac <- factor(fac,                               # nimmt den alten Factor
              levels = c("real", "abi", "ba"),   # hier wird die Reihenfolge bestimmt
              ordered = TRUE,                    # und R mitgeteilt, dass diese auch bitte beachtet werden soll
              labels = c("Realschulabschluss", "Abitur", "Bacholor") # Hier werden die Anzeigenamen bestimmt
              )
```

Manche Funktionen kommen nicht mit einem klassichen Vektor klar, andere nicht mit einem Factor. Hier ist es relativ einfach möglich `as.numeric()` bzw. `as.factor()` zu verwenden.

</details>


### Zwei-dimensionale Objekte: Dataframes, Matrizen, Tibbles

Die 2 Dimensionen in Daten heißt: *Zeilen* UND *Spalten*, bzw. *rows* und *columns*. Also das gleiche Konzept wie bei jeder klassischen Tabelle.

R unterscheidet dabei 3 Arten von Tabellen: Dataframes, Matritzen und Tibbles.

#### Dataframes
**Dataframes**: Sind die mehrdimensionale Datenstruktur, die dir am häufigsten begegnen wird, mit der eigentlich standardmäßig gearbeitet wird. Wie eine Tabelle. Im Grunde mehrere nebeneinander geklebte Vektoren. Sie werden folgendermaßen erstellt:

```{r class_df, exercise = TRUE}
# Das Objekt wird benannt; es folgt ein Zuweisungspfeil; und die Funktion, die einen Dataframe erstellt
data_df <- data.frame(
  # Variablennamen für die erste Variable festlegen; hier folgt ein Gleichzeichen, kein Pfeil; Inhalt festlegen
  namen = c("Joh", "Ma", "Lio"),
  weg_km = c(1, 5, 2),
  fahrzeug = c("Fuss", "Tram", "Rad")
)

data_df

typeof(data_df)
class(data_df)
```

Das `list` weist darauf hin, dass es verschiedene Datentypen in diesem Objekt gibt. Die Objektklasse `data.frame` ist genau das, was wir erwartet haben. 

Da Dataframes so enorm wichtig sind, werden sie in einem eigenen Tutorial nochmal in Gänze vorgestellt.

#### Matrix
Eine **Matrix** ist eine andere zweidimensionale Datenstruktur, die im Gegensatz zu einem Dataframe nur aus einem Datentyp besteht (z. B. `numerisch`, `character`). Sie wird dir nicht so häufig über den Weg laufen - dafür kannst du auch lineare Algebra etc. mit ihr rechnen.

```{r class_mat, exercise = TRUE}
# matrix() erstellt eine Matrix; 
# data: EIN atomic Vector oder wird (meist mit viel Datenverlus in einen atomic Vector hinein gezwungen/ coerced); 
# nrow: Reihenanzahl; ncol: Spaltenanzahl
data_mat_1 <- matrix(data = 1:6, nrow = 2, ncol = 3)
data_mat_2 <- matrix(1:6, nrow = 3, ncol = 2)

data_mat_1
data_mat_2

typeof(data_mat_1)
class(data_mat_1)
```

Da Matritzen nur einen Datentyp haben zeigt `typeof()` diesen auch an. Und `class()` sagt, wie erwartet, dass es sich um eine Matrix handelt.

#### Tibbles
**Tibbles** sind eine Sonderangelegenheit von R, die im Paket *Tidyverse* mitgeliefert werden. Es sind quasi Dataframes nur in gemütlich.

```{r class_tbl, exercise = TRUE}
# notwendiges Paket aktivieren
library(tibble)

data_tbl <- tibble(
  namen = c("Joh", "Ma", "Lio"),
  weg_km = c(1, 5, 2),
  fahrzeug = c("Fuss", "Tram", "Rad")
)

data_tbl
# gibt auf einen Blick mehr Infos aus

typeof(data_tbl)
class(data_tbl)
```

#### Mehrdimensionale Objekte: Listen und Arrays

**Listen** sind grob gesagt mehrdimensionale Dataframes - es können also mehrere Dataframes in einem Objekt gespeichert werden. Die sind besonders wichtig, wenn das Arbeiten mit R noch mehr ins Programmieren geht und Schrittweise Dinge abgespeichert werden sollen, sehr komplexe Daten berechnet werden oder auch häufig die Ausgabe von komplexeren Funktionen benötigt wird. 

```{r class-setup}
data_df <- data.frame(
  # Variablennamen für die erste Variable festlegen; hier folgt ein Gleichzeichen, kein Pfeil; Inhalt festlegen
  namen = c("Joh", "Ma", "Lio"),
  weg_km = c(1, 5, 2),
  fahrzeug = c("Fuss", "Tram", "Rad")
)

data_mat_1 <- matrix(data = 1:6, nrow = 2, ncol = 3)
data_mat_2 <- matrix(1:6, nrow = 3, ncol = 2)

```

```{r class, exercise = TRUE}
data_lis <-list(
  df_alt = data_df,
  mat_1_alt = data_mat_1,
  mat_2_alt = data_mat_2,
  neue_daten_1 = 1:10,
  neue_daten_2 = "Hier kommt einfach ein bisschen random Text hin."
)

data_lis

typeof(data_lis)
class(data_lis)
```

Um zu lernen, wie du auf einzelne Listenelemente zugreifen kannst, schaue gerne in das Tutorial zur Indizierung.

**Arrays** verhalten sich zu Listen wie Dataframes zu Matrizenn: Sie bestehen ebenfalls aus lediglich einem Datentypen und sind mehrdimensional. Auch diese sind eine eher selten vorkommende Klasse.

```{r class_arr, exercise = TRUE}
data_arr <- array(1:24, dim = c(2, 3, 4))

data_arr

typeof(data_arr)
class(data_arr)
```

Das waren die am häufigsten vorkommenden Objektklassen. Aber keine Bange, dass musst du nicht alles auswendig können und wurde hier teilweise auch nur vollständigkeitshalber erklärt. Es ermöglicht dir jedoch in der Zukunft mögliche Fehlercodes basierend auf Klassen- oder Typfehler zu verstehen und mit `typeof()` und `class()` eine Lösung zu finden.

## Abschlussquiz

```{r abschlussquiz}
quiz(caption = "Teste dein Wissen!",
     question_checkbox("Warum sollte die Option, das Environment auch zwischen
                       den Sitzungen zu speichern, deaktiviert werden?",
                    answer("Um uns das Leben nicht unnötig leicht zu machen.",
                           message = "Alles in R ist mit dem Ziel entstanden, 
                           das Leben von Forschenden etwas leichter zu machen,
                           auch wenn es manchmal nicht so scheint."),
                    answer("Um Replizierbarkeit zu fördern.", 
                           correct = TRUE,
                           message = "Wenn alle Objekte (z.B. Variablen), die 
                           für ein Skript nötig sind, immer im Skript definiert
                           werden, kann es nicht zu Verwechslungen kommen und 
                           auch andere, die das Skript bekommen, können es
                           ausführen, ohne zu wissen was alles vorher in deinem
                           Environment war."),
                    answer("Um nicht ausversehen mit alten Werten aus der 
                           letzten Sitzung zu rechnen.", 
                           correct = TRUE, 
                           message = "Wenn du in einer vorherigen Sitzung `x`
                           definiert hast, und in der neuen Sitzung an einem
                           anderen Skript arbeitest, wo es auch eine Variable
                           namens `x` gibt, könntest du ausversehen mit den
                           falschen Werten arbeiten, wenn `x` 
                           zwischengespeichert wird."),
                    answer("Um Arbeitsspeicher zu sparen und Abstürze zu
                           verhindern.", 
                           message = "Diese Option blockiert keinen
                           Arbeitsspeicher, wenn sie aktiviert sind"),
                    answer("Um nicht immer wieder das ganze Skript ausführen zu
                           müssen, um an meine Berechnungsergebnisse 
                           zu kommen.", 
                           message = "Selbst wenn das ganze Skript sehr
                           rechenintensiv ist, meinetwegen 3 Tage auf einem
                           Super-Computer laufen muss um die Ergebnisse zu
                           erhalten, würdest du diese nicht im Environment
                           speichern wollen, sondern dann lieber am Ende des
                           Skripts mit einem Befehl in eine Datei auf der
                           Festplatte schreiben."),
                    random_answer_order = TRUE,
                    allow_retry = TRUE),
     question_text("Wie heißt dieser Operator `<-` auf Englisch?",
                   answer("assignment operator", correct = TRUE),
                   answer("Assignment Operator", correct = TRUE), allow_retry = T),
     question_radio("Worauf könnte dieser Fehler hinweisen? \n`non-numeric argument to binary operator`",
                    answer("Dass einer Funktion wie z.B. `+` oder `-`, die Zahlen zum Rechnen braucht, Text als Input gegeben wurde.", correct = TRUE),
                    answer("Dass einer Funktion die Text erwartet, fälschlicherweise Zahlen als Input gegeben wurden."),
                    answer("Dass der PC so kaputt ist, dass nicht einmal mehr die Grundrechenarten funktionieren."), allow_retry = TRUE),
      question_checkbox("Welches sind am häufigsten verwendeten Datentypen in R?",
                    answer("character", correct = T),
                    answer("single", message = "Das ist zwar ein Datentyp in R aber sehrsehr selten, da R default mäßig Daten in doppelter Präzision (double precision/ 64 bit) speichert."),
                    answer("double", correct = TRUE),
                    answer("vector", message = "Das ist eine Objektklasse, kein Datentyp."),
                    answer("numeric", message = "Das ist eine Objektklasse, kein Datentyp"),
                    random_answer_order = TRUE,
                    allow_retry = TRUE),
     question_checkbox("Was kann R alles als logischen Vektor verarbeiten?",
                       answer("1 und 0", correct = T),
                       answer("T und F", correct = T),
                       answer("WAHR und FALSCH", message = "Das ist schon nah dran. Jetzt noch einmal ins englische übersetzen, dann hast du es :)"),
                       answer("TRUE und FALSE", correct = T),
                      answer("W und F", message = "Das ist schon nah dran. Jetzt noch einmal ins englische übersetzen, dann hast du es :)"),
                      random_answer_order = TRUE,
                    allow_retry = TRUE)
                       )

```

## Learnings heute

```{r context="server"}
# Shiny App um die Anzahl richtig beantworteter Fragen anzuzeigen. 
# Funktioniert in jedem Tutorial

shiny::observeEvent(
  input$get_score, 
  {
    objs2 = learnr:::get_tutorial_state()
    
    # Number of correct questions
    
    n_correct <- 
      # Access the $correct sublist item in each list item
        lapply(objs2, purrr::pluck, "correct") |>
           # make it a vector containing: TRUE and FALSE and NAs
           # NA is appearing for list items which don't have
           # a $correct subitem
                unlist() |> 
           # Taking the sum of a logical Vector returns the number of TRUEs
                sum(na.rm=TRUE)
    
    # Number of total questions
    
    total_questions <- 
      # 1. Access $type in each list item and make it a vector of types
      lapply(objs2, purrr::pluck, "type") |> unlist()
    
    # 2. Count the number of "question" in that vector
    total_questions <- total_questions[total_questions == "question"] |> 
      length()
      
      
    output$score = shiny::renderText(
      paste0(n_correct, " von ", total_questions,
        " im gesamten Tutorial beantworteten Fragen waren richtig.")
)
    invisible()
  }
)
```

```{r score, echo=FALSE}
shiny::br()
shiny::actionButton("get_score", "Auswertung!")
shiny::br()
shiny::br()
shiny::textOutput("score")
shiny::br()
```

### Zusammenfassung

Du hast gelernt, wie du Variablen Daten zuweisen kannst.

Variablen sind in R repräsentiert als Vektoren. Vektoren sind der fundamentale Objekttyp in R, auf dem alle anderen Objekte wie z.B. Tabellen aufbauen. Ihr Vorteil ist, dass sie viele Elemente enthalten können.

Beim Rechnen mit Vektoren hast du das Konzept "Recycling" kennengelernt, und erahnst ungefähr, was "Vektorisierung" ist - dass vektorisierte Funktionen wie `+` auf jedes Element eines Vektors einzeln angewendet werden, und als Ergebnis auch wieder ein Vektor steht.

Beim Assigment hast du gelernt, Leerzeichen um den Assignment Operator `<-` zu verwenden. 

Das Dezimaltrennzeichen in R ist der Punkt `.`.
Kommata werden verwendet, um Werte oder Argumente in Aufzählungen voneinander zu trennen.

Gute Objektnamen sind konsistent und kleingeschrieben und dürfen keine Leerzeichen enthalten oder mit einer Zahl beginnen.

Im Environment werden die erstellten Objekte der laufenden Sitzung angezeigt. Bei Beenden von RStudio werden sie gelöscht, was die empfohlene Einstellung ist. So wird Replizierbarkeit trainiert: Nicht die erstellten Variablen werden aufbewahrt, sondern das Rezept um sie zu erstellen - in Form eines Skripts.

Darüber hinaus hast du nun ein Bild davon, welche wichtigen Datentypen (`double`, `integer`, `character` und `logical`) du in R wofür verwenden kannst. 

### Diese neuen Konzepte kennst du nun:

-   Assignment `<-`

-   Environment

-   Vektoren

-   Recycling und Vektorisierung

-   Zahlenreihen mit `:`

-   Datentypen

-   Objektklassen

### neue Funktionen

| Code  | Beschreibung         |
|-------|----------------------|
| `c()` | combine, Vektor erstellen |
| `<-`  | assignment operator: Objekte speichern |
| `:`   | colon operator: Zahlenreihen erstellen |
| `typeof()` | Datentyp bestimmen |
| `class()`   | Objektklasse bestimmen |
| `length()` | Länge eines Vektors |
| `as.double()` | Umwandlung in logischen Vektor |
| `as.integer()` | Umwandlung in Integer-Vektor (**Achtung: Fließkommazahlen werden immer nach unten gerundet!**) |
| `as.character()` | Umwandlung in Buchstabenvektor |
| `as.logical()` | Umwandlung in logischen Vektor |
| `as.numeric()` | Umwandlung in Zahlenvektor (*häufiger verwendet als `as.double()`) |
| `as.factor()`  | Umwandlung in Factor |
| `as.data.frame()` | Umwandlung in dataframe |
| `as.matrix()` | Umwandlung in Matrix |
| `as.tibble()` | Umwandlung in tibble |
| `as.list()`   | Umwandlung in Liste |
| `as.array()` | Umwandlung in Array |
|`is.double()` | Logische Abfrage, analog zu den anderen Typen und Klassen abwandelbar |

## Hash generieren

Wenn du mit deinen Antworten im Tutorial zufrieden bist, generiere dir deinen Hash-Code, kopiere ihn und lade ihn bei der entsprechenden Abgabe auf Moodle hoch!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui(ui_before = NULL)
```

### [**Moodle-Kurs öffnen**](https://moodle.uni-kassel.de/course/view.php?id=19918)

## Credit
Dieses Tutorial wurde von Lukas Bruelheide sowie Gesa Graf geschrieben. \
Dank gilt auch Jeffrey Ohene für 
das Korrigieren einiger Tippfehler und die Umsetzung einer konsistenten Anrede mit "du".  
